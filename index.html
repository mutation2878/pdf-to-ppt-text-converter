<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>NotebookLM PDF è½‰ PPT (V36.4 å®Œç¾åº§æ¨™ä¿®æ­£ç‰ˆ)</title>
    
    <link rel="manifest" href="manifest.json">
    <script>
      if ('serviceWorker' in navigator) {
        try {
            navigator.serviceWorker.register('sw.js').catch(err => console.log('SW Skip:', err));
        } catch (e) {}
      }
    </script>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        body { font-family: 'Microsoft JhengHei', 'Noto Sans TC', sans-serif; background-color: #f3f4f6; height: 100vh; overflow: hidden; }
        
        .page-card { transition: all 0.2s; border: 2px solid transparent; cursor: pointer; }
        .page-card:hover { transform: translateY(-2px); }
        .page-card.active { border-color: #2563eb; background-color: #eff6ff; }
        .page-card.done { border-color: #10b981; }

        canvas { touch-action: none; }
        .cursor-pipette { cursor: crosshair !important; }

        /* Scrollbar Styling */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-track { background-color: transparent; }

        /* Slider Styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: #cbd5e1;
            border-radius: 5px;
            outline: none;
            height: 6px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px; 
            height: 18px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* OCR Box Styling */
        .ocr-box { position: absolute; cursor: pointer; z-index: 40; transition: all 0.1s; }
        .click-through .ocr-box { pointer-events: none !important; }

        /* Green Box (Keep) */
        .ocr-box.keep { border: 1px solid #22c55e; background-color: rgba(34, 197, 94, 0.05); }
        .ocr-box.keep:hover { background-color: rgba(34, 197, 94, 0.2); box-shadow: 0 0 5px #22c55e; }

        /* Red Box (Mask + Text) */
        .ocr-box.mask-text { border-color: #ef4444; background-color: rgba(239, 68, 68, 0.2); }
        .ocr-box.mask-text::after {
            content: 'é‡å»º'; position: absolute; top: -14px; right: 0;
            background: #ef4444; color: white; font-size: 10px; padding: 1px 4px; border-radius: 4px;
        }
        .ocr-box.mask-text:hover { background-color: rgba(239, 68, 68, 0.3); box-shadow: 0 0 5px #ef4444; }

        /* Blue Box (Text Only) */
        .ocr-box.text-only { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.1); }
        .ocr-box.text-only::after {
            content: 'åƒ…è²¼å­—'; position: absolute; top: -14px; right: 0;
            background: #3b82f6; color: white; font-size: 10px; padding: 1px 4px; border-radius: 4px;
        }
        .ocr-box.text-only:hover { background-color: rgba(59, 130, 246, 0.2); box-shadow: 0 0 5px #3b82f6; }

        .loader {
            border: 3px solid #e5e7eb; border-top: 3px solid #2563eb; border-radius: 50%;
            width: 24px; height: 24px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="flex flex-col text-slate-800">

    <!-- Header -->
    <header class="bg-white shadow-sm z-30 p-3 flex justify-between items-center shrink-0 h-16 relative">
        <div class="flex items-center gap-2">
            <div class="bg-blue-600 text-white p-1.5 rounded-lg font-bold text-xl">N</div>
            <h1 class="text-xl font-bold hidden sm:block">PDF è½‰ PPT <span class="text-xs bg-purple-600 text-white px-2 py-0.5 rounded ml-1">V36.4 Fix</span></h1>
        </div>
        
        <div class="flex items-center gap-2 sm:gap-3">
            <div class="flex flex-col items-end">
                <input type="password" id="apiKey" class="border rounded px-2 py-1 text-sm w-32 sm:w-64 focus:border-blue-500 outline-none" placeholder="Gemini API Key">
            </div>
            
            <label class="bg-slate-700 hover:bg-slate-800 text-white px-3 py-2 rounded cursor-pointer flex items-center gap-2 text-sm shadow transition">
                <i data-lucide="folder-open" class="w-4 h-4"></i> <span class="hidden sm:inline">é–‹å•Ÿ PDF</span>
                <input type="file" id="pdfInput" accept=".pdf" class="hidden">
            </label>
            <button id="downloadBtn" onclick="exportPPT()" class="bg-emerald-600 hover:bg-emerald-700 text-white px-3 py-2 rounded flex items-center gap-2 text-sm shadow disabled:opacity-50 disabled:cursor-not-allowed transition" disabled>
                <i data-lucide="download" class="w-4 h-4"></i> <span class="hidden sm:inline">ä¸‹è¼‰ PPT</span>
            </button>
        </div>
    </header>

    <!-- Main -->
    <div class="flex flex-1 overflow-hidden relative">
        
        <!-- Left: List -->
        <div class="w-64 bg-white border-r flex flex-col shrink-0 z-20 shadow-sm">
            <div class="p-3 border-b bg-slate-50 flex justify-between items-center">
                <span id="pageCount" class="font-bold text-slate-600 text-xs">ç­‰å¾…æª”æ¡ˆ...</span>
                <button id="autoRunBtn" onclick="startAutoRun()" class="hidden text-blue-600 text-xs font-bold hover:underline">
                    å…¨éƒ¨è‡ªå‹•åˆ†æ
                </button>
            </div>
            <div id="pagesList" class="flex-1 overflow-y-auto p-3 space-y-3 bg-slate-50 custom-scrollbar">
                <div class="text-center text-slate-400 text-xs mt-10">è«‹å…ˆä¸Šå‚³ PDF</div>
            </div>
        </div>

        <!-- Right: Editor -->
        <div class="flex-1 bg-slate-100 relative flex flex-col h-full overflow-hidden">
            
            <!-- Toolbar -->
            <div id="toolbar" class="hidden bg-white p-2 shadow-sm border-b flex items-center justify-between gap-4 shrink-0 z-20 overflow-x-auto custom-scrollbar">
                
                <!-- Zoom & Mode -->
                <div class="flex items-center gap-2 shrink-0">
                     <div class="flex items-center gap-1 bg-slate-100 p-1 rounded-lg border border-slate-200">
                        <button onclick="changeZoom(-0.2)" class="p-1.5 rounded hover:bg-white transition text-slate-600" title="ç¸®å°">
                            <i data-lucide="minus" class="w-4 h-4"></i>
                        </button>
                        <span id="zoomLabel" class="text-xs font-bold w-10 text-center select-none">100%</span>
                        <button onclick="changeZoom(0.2)" class="p-1.5 rounded hover:bg-white transition text-slate-600" title="æ”¾å¤§">
                            <i data-lucide="plus" class="w-4 h-4"></i>
                        </button>
                    </div>

                    <div class="flex items-center gap-1 bg-slate-100 p-1 rounded-lg border border-slate-200">
                        <button onclick="setMode('select')" id="btn-mode-select" class="px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition bg-white shadow text-blue-700" title="é¸å–æ¨¡å¼">
                            <i data-lucide="mouse-pointer-2" class="w-4 h-4"></i>
                        </button>
                        <button onclick="setMode('brush')" id="btn-mode-brush" class="px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition text-slate-500 hover:text-slate-700" title="å¡—é´‰æ¨¡å¼">
                            <i data-lucide="brush" class="w-4 h-4"></i>
                        </button>
                    </div>
                    
                    <label class="flex items-center gap-1 cursor-pointer bg-slate-50 border px-2 py-1.5 rounded-lg hover:bg-slate-100 transition shrink-0 select-none">
                        <input type="checkbox" id="mergeToggle" class="rounded text-blue-600 focus:ring-blue-500" onchange="toggleMerge()">
                        <span class="text-xs font-bold text-slate-600">åˆä½µæ®µè½</span>
                    </label>
                </div>

                <!-- Tools -->
                <div class="flex items-center gap-3 shrink-0">
                    <button onclick="analyzeCurrentPage()" class="bg-indigo-50 text-indigo-700 px-3 py-1.5 rounded-lg text-xs font-bold flex items-center gap-2 hover:bg-indigo-100 transition border border-indigo-200 shadow-sm whitespace-nowrap">
                        <i data-lucide="scan-text" class="w-4 h-4"></i> <span class="hidden xl:inline">åˆ†ææ’ç‰ˆ</span><span class="xl:hidden">åˆ†æ</span>
                    </button>

                    <div class="flex items-center gap-2 border-l pl-3 bg-slate-50 p-1 rounded-lg border border-slate-200">
                        <button id="eyedropperBtn" onclick="toggleEyedropper()" class="p-1.5 border rounded bg-white hover:bg-slate-100 text-slate-600 transition shadow-sm" title="å¸ç®¡å–è‰²">
                            <i data-lucide="pipette" class="w-4 h-4"></i>
                        </button>
                        <div class="relative w-8 h-8 rounded border overflow-hidden shadow-sm cursor-pointer hover:scale-105 transition">
                             <input type="color" id="maskColor" value="#FFFFFF" class="absolute -top-2 -left-2 w-16 h-16 p-0 border-0 cursor-pointer" title="é¸æ“‡é¡è‰²">
                        </div>
                        
                        <div class="w-px h-4 bg-slate-300 mx-1"></div>
                        
                        <span class="text-xs font-bold text-slate-500 select-none">ç­†åˆ·:</span>
                        <!-- Wide Input Range for Visibility -->
                        <div class="relative w-32 flex items-center px-2">
                             <input type="range" id="brushSize" min="5" max="100" value="20" class="w-full h-6 cursor-pointer z-10" title="èª¿æ•´ç­†åˆ·å¤§å°">
                        </div>
                        
                        <button onclick="undoLastStroke()" class="text-slate-500 hover:text-blue-600 p-1.5 transition border rounded bg-white shadow-sm" title="å¾©åŸä¸Šä¸€ç­† (Undo)">
                            <i data-lucide="undo-2" class="w-4 h-4"></i>
                        </button>
                        
                        <button onclick="clearMask()" class="text-slate-400 hover:text-red-500 p-1.5 transition" title="æ¸…é™¤æ‰€æœ‰å¡—é´‰">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Preview Area (Fixed Scroll Issue) -->
            <!-- Using display:flex + justify-center + align-items-start to ensure content is centered but scrollable without clipping -->
            <div id="previewArea" class="flex-1 overflow-auto bg-slate-200 relative hidden p-8 custom-scrollbar flex flex-col items-center">
                
                <!-- Container: Margin auto centers it when smaller than viewport, allows scroll when larger -->
                <div id="canvasContainer" class="relative shadow-2xl bg-white hidden flex-shrink-0 m-auto" style="width: 0; height: 0;">
                    
                    <!-- 1. PDF Layer -->
                    <canvas id="pdfCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>
                    
                    <!-- 2. Drawing Layer -->
                    <canvas id="maskCanvas" class="absolute top-0 left-0 w-full h-full z-20 cursor-crosshair touch-none"></canvas>

                    <!-- 3. Overlay Layer -->
                    <div id="textOverlay" class="absolute top-0 left-0 w-full h-full z-30 pointer-events-none"></div>

                    <!-- Loader -->
                    <div id="canvasLoader" class="absolute inset-0 bg-white/90 z-50 hidden flex flex-col items-center justify-center backdrop-blur-sm">
                        <div class="loader mb-3"></div>
                        <span class="text-sm font-bold text-slate-600 animate-pulse" id="loaderText">AI é‹ç®—ä¸­...</span>
                    </div>
                </div>
            </div>

            <div id="emptyState" class="flex-1 flex flex-col items-center justify-center text-slate-400">
                <i data-lucide="mouse-pointer-2" class="w-16 h-16 mb-4 opacity-20"></i>
                <p class="text-sm font-bold opacity-60">è«‹å¾å·¦å´åˆ—è¡¨é¸æ“‡ä¸€é é–‹å§‹ç·¨è¼¯</p>
            </div>
            
            <div class="bg-white border-t p-2 px-4 flex justify-between items-center text-xs text-slate-500 shrink-0 z-20">
                <div id="statusText">è«‹ä¸Šå‚³æª”æ¡ˆ</div>
                <div class="font-bold flex gap-3 text-xs">
                    <span class="text-green-600">ğŸŸ© åŸåœ–</span>
                    <span class="text-gray-300">|</span>
                    <span class="text-red-400">ğŸŸ¥ é®è“‹+è²¼å­—</span>
                    <span class="text-gray-300">|</span>
                    <span class="text-blue-500">ğŸŸ¦ åƒ…è²¼å­—(æ¨è–¦)</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        if (typeof lucide !== 'undefined') lucide.createIcons();

        // State
        let pdfDoc = null;
        let pdfPages = [];
        let currentIndex = -1;
        let editMode = 'select'; 
        let isDrawing = false;
        let isEyedropper = false;
        let zoomLevel = 1.0; 

        // API Models
        const MODELS = ["gemini-2.5-flash-preview-09-2025", "gemini-1.5-flash"];

        // DOM Elements
        const apiKeyInput = document.getElementById('apiKey');
        const fileInput = document.getElementById('pdfInput');
        const pagesList = document.getElementById('pagesList');
        const previewArea = document.getElementById('previewArea');
        const canvasContainer = document.getElementById('canvasContainer');
        const textOverlay = document.getElementById('textOverlay');
        const emptyState = document.getElementById('emptyState');
        const toolbar = document.getElementById('toolbar');
        const statusTextEl = document.getElementById('statusText'); 
        
        const pdfCanvas = document.getElementById('pdfCanvas');
        const maskCanvas = document.getElementById('maskCanvas');
        const maskCtx = maskCanvas.getContext('2d');
        const canvasLoader = document.getElementById('canvasLoader');
        const loaderText = document.getElementById('loaderText');
        const zoomLabel = document.getElementById('zoomLabel');
        const mergeToggle = document.getElementById('mergeToggle');
        
        const maskColorInput = document.getElementById('maskColor');
        const brushSizeInput = document.getElementById('brushSize');
        const eyedropperBtn = document.getElementById('eyedropperBtn');
        const btnModeSelect = document.getElementById('btn-mode-select');
        const btnModeBrush = document.getElementById('btn-mode-brush');

        // --- 1. File Handling ---
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (file.type !== 'application/pdf') return alert('è«‹ä¸Šå‚³ PDF');

            const reader = new FileReader();
            reader.onload = async function() {
                try {
                    document.getElementById('pageCount').textContent = 'è®€å–ä¸­...';
                    pdfDoc = await pdfjsLib.getDocument(new Uint8Array(this.result)).promise;
                    document.getElementById('pageCount').textContent = `å…± ${pdfDoc.numPages} é `;
                    document.getElementById('autoRunBtn').classList.remove('hidden');
                    renderThumbnails();
                } catch (e) { alert('PDF è®€å–å¤±æ•—: ' + e.message); }
            };
            reader.readAsArrayBuffer(file);
        };

        async function renderThumbnails() {
            pagesList.innerHTML = '';
            pdfPages = [];
            
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const page = await pdfDoc.getPage(i);
                const viewport = page.getViewport({ scale: 0.2 });
                const canvas = document.createElement('canvas');
                canvas.width = viewport.width; canvas.height = viewport.height;
                await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;

                const div = document.createElement('div');
                div.className = 'page-card bg-white p-2 rounded-lg shadow-sm border border-slate-200 flex items-center gap-3 hover:bg-blue-50';
                div.innerHTML = `
                    <div class="font-bold text-slate-400 text-xs w-6">P.${i}</div>
                    <img src="${canvas.toDataURL()}" class="h-12 w-auto border border-slate-200 rounded">
                    <div class="flex-1 text-right">
                        <div class="status-badge text-[10px] bg-slate-100 text-slate-500 px-2 py-1 rounded-full inline-block">æœªåˆ†æ</div>
                    </div>
                `;
                div.onclick = () => loadPage(i - 1);
                pagesList.appendChild(div);

                pdfPages.push({ 
                    pageNum: i, 
                    el: div, 
                    rawData: null,  
                    displayData: null,
                    blockStates: [],
                    viewport: page.getViewport({ scale: 1.0 }),
                    strokes: [] // Store Normalized strokes
                });
            }
        }

        // --- 2. Load & Zoom Logic ---
        async function loadPage(index) {
            currentIndex = index;
            const item = pdfPages[index];

            document.querySelectorAll('.page-card').forEach(c => c.classList.remove('active'));
            item.el.classList.add('active');
            
            emptyState.classList.add('hidden');
            previewArea.classList.remove('hidden');
            toolbar.classList.remove('hidden');

            renderPageWithZoom(item);
        }

        async function renderPageWithZoom(item) {
            const pdfW = item.viewport.width;
            const pdfH = item.viewport.height;
            const ratio = pdfW / pdfH;
            
            // Calculate base dimensions relative to viewport to ensure good fit
            const baseW = window.innerWidth * 0.7; 
            const baseH = window.innerHeight * 0.8;
            
            let finalW, finalH;
            if (baseW / baseH > ratio) {
                 finalH = baseH * zoomLevel;
                 finalW = finalH * ratio;
            } else {
                 finalW = baseW * zoomLevel;
                 finalH = finalW / ratio;
            }

            // Apply size to container
            canvasContainer.style.width = `${finalW}px`;
            canvasContainer.style.height = `${finalH}px`;
            canvasContainer.classList.remove('hidden');

            // Set canvas internal resolution based on zoom (Sharper text)
            const scale = 2.0 * zoomLevel; 
            pdfCanvas.width = pdfW * scale;
            pdfCanvas.height = pdfH * scale;
            maskCanvas.width = pdfW * scale;
            maskCanvas.height = pdfH * scale;

            // Render PDF
            const page = await pdfDoc.getPage(item.pageNum);
            await page.render({ 
                canvasContext: pdfCanvas.getContext('2d'), 
                viewport: page.getViewport({ scale: scale }) 
            }).promise;

            // Redraw Strokes using Normalized Coordinates (CRITICAL FIX)
            redrawStrokes(item);

            // Handle Merging
            if (mergeToggle.checked) {
                item.displayData = mergeTextBlocks(item.rawData);
            } else {
                item.displayData = item.rawData;
            }
            
            if (item.displayData && item.blockStates.length !== item.displayData.length) {
                 item.blockStates = new Array(item.displayData.length).fill(0);
            }

            renderTextOverlay();
            updateStatus(item.rawData ? 'success' : 'idle');
            setMode(editMode); 
        }

        function changeZoom(delta) {
            zoomLevel = Math.max(0.5, Math.min(zoomLevel + delta, 3.0));
            zoomLabel.textContent = `${Math.round(zoomLevel * 100)}%`;
            if (currentIndex !== -1) {
                renderPageWithZoom(pdfPages[currentIndex]);
            }
        }

        // --- 3. Coordinate Logic (Normalization) ---
        // Converts Screen Event -> Normalized Coordinates (0.0 to 1.0)
        function getNormalizedPoint(e) {
            const rect = maskCanvas.getBoundingClientRect();
            // Offset inside the element
            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;
            
            // Normalize: 0.0 (left/top) to 1.0 (right/bottom)
            return {
                x: offsetX / rect.width,
                y: offsetY / rect.height
            };
        }

        // --- 4. Drawing Logic (Normalized Storage) ---
        function startDrawing(e) {
            if (isEyedropper) { pickColor(e); return; }
            if (editMode !== 'brush') return;
            isDrawing = true;
            
            const pt = getNormalizedPoint(e);
            
            // Normalized brush size (relative to 1000px base width)
            // If canvas is 1000px, size 20 = 20px. If 2000px, size 20 = 40px.
            const normSize = brushSizeInput.value / 1000;

            // Start new stroke
            pdfPages[currentIndex].strokes.push({
                color: maskColorInput.value,
                normSize: normSize,
                points: [{x: pt.x, y: pt.y}]
            });
            
            // Draw visual feedback (immediate)
            // Need pixel coords for canvas context
            const pixelX = pt.x * maskCanvas.width;
            const pixelY = pt.y * maskCanvas.height;
            const pixelSize = normSize * maskCanvas.width;

            maskCtx.beginPath();
            maskCtx.lineCap = 'round';
            maskCtx.lineJoin = 'round';
            maskCtx.lineWidth = pixelSize;
            maskCtx.strokeStyle = maskColorInput.value;
            maskCtx.moveTo(pixelX, pixelY);
            maskCtx.stroke(); // Draw dot
            
            // Store last normalized point for lineTo
            // We actually need pixel coords for drawing continuation
            // But we push normalized coords to history
        }

        function draw(e) {
            if (!isDrawing) return;
            const pt = getNormalizedPoint(e);
            
            const currentStroke = pdfPages[currentIndex].strokes.slice(-1)[0];
            
            // Use Pixel coords for drawing on screen
            const pixelX = pt.x * maskCanvas.width;
            const pixelY = pt.y * maskCanvas.height;
            
            // Get previous point (convert back to pixels)
            const prevNorm = currentStroke.points[currentStroke.points.length - 1];
            const prevPixelX = prevNorm.x * maskCanvas.width;
            const prevPixelY = prevNorm.y * maskCanvas.height;

            maskCtx.beginPath();
            maskCtx.lineCap = 'round';
            maskCtx.lineJoin = 'round';
            maskCtx.lineWidth = currentStroke.normSize * maskCanvas.width;
            maskCtx.strokeStyle = currentStroke.color;
            maskCtx.moveTo(prevPixelX, prevPixelY);
            maskCtx.lineTo(pixelX, pixelY);
            maskCtx.stroke();

            // Store normalized point
            currentStroke.points.push({x: pt.x, y: pt.y});
        }

        function stopDrawing() { 
            isDrawing = false;
            checkAllDone();
        }

        function redrawStrokes(item) {
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            if(!item.strokes) item.strokes = [];
            
            const w = maskCanvas.width;
            const h = maskCanvas.height;

            item.strokes.forEach(stroke => {
                if(stroke.points.length < 1) return;
                
                maskCtx.beginPath();
                maskCtx.lineCap = 'round';
                maskCtx.lineJoin = 'round';
                
                // Scale normalized size to current canvas pixel width
                maskCtx.lineWidth = stroke.normSize * w; 
                maskCtx.strokeStyle = stroke.color;
                
                // Scale normalized points to current canvas pixel dims
                const startX = stroke.points[0].x * w;
                const startY = stroke.points[0].y * h;
                
                maskCtx.moveTo(startX, startY);
                for(let i=1; i<stroke.points.length; i++) {
                    const px = stroke.points[i].x * w;
                    const py = stroke.points[i].y * h;
                    maskCtx.lineTo(px, py);
                }
                maskCtx.stroke();
            });
        }

        function undoLastStroke() {
            if(currentIndex === -1) return;
            const item = pdfPages[currentIndex];
            if(item.strokes && item.strokes.length > 0) {
                item.strokes.pop();
                redrawStrokes(item);
                checkAllDone();
            }
        }

        // Event Listeners
        maskCanvas.addEventListener('mousedown', startDrawing);
        maskCanvas.addEventListener('mousemove', draw);
        maskCanvas.addEventListener('mouseup', stopDrawing);
        maskCanvas.addEventListener('mouseout', stopDrawing);
        maskCanvas.addEventListener('touchstart', (e)=>{e.preventDefault(); startDrawing(e.touches[0])}, {passive:false});
        maskCanvas.addEventListener('touchmove', (e)=>{e.preventDefault(); draw(e.touches[0])}, {passive:false});
        maskCanvas.addEventListener('touchend', stopDrawing);

        // --- 5. Other Interaction Logic ---
        function toggleEyedropper() {
            isEyedropper = !isEyedropper;
            eyedropperBtn.classList.toggle('text-blue-600', isEyedropper);
            eyedropperBtn.classList.toggle('bg-blue-100', isEyedropper);
            maskCanvas.classList.toggle('cursor-pipette', isEyedropper);
            if(isEyedropper) {
                textOverlay.style.pointerEvents = 'none';
                maskCanvas.style.pointerEvents = 'auto';
            } else {
                setMode(editMode); 
            }
        }

        function pickColor(e) {
            // Need pixel coords for getImageData
            const rect = maskCanvas.getBoundingClientRect();
            const scaleX = maskCanvas.width / rect.width;
            const scaleY = maskCanvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            const ctx = pdfCanvas.getContext('2d');
            const p = ctx.getImageData(x, y, 1, 1).data;
            const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
            maskColorInput.value = hex;
            toggleEyedropper();
        }

        function setMode(mode) {
            editMode = mode;
            if (mode === 'select') {
                btnModeSelect.className = "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition bg-white shadow text-blue-700";
                btnModeBrush.className = "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition text-slate-500 hover:text-slate-700";
                maskCanvas.style.pointerEvents = 'none'; 
                textOverlay.style.pointerEvents = 'auto'; 
                textOverlay.classList.remove('click-through'); 
                textOverlay.style.opacity = '1';
            } else {
                btnModeSelect.className = "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition text-slate-500 hover:text-slate-700";
                btnModeBrush.className = "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition bg-white shadow text-blue-700";
                maskCanvas.style.pointerEvents = 'auto'; 
                textOverlay.style.pointerEvents = 'none'; 
                textOverlay.classList.add('click-through'); 
                textOverlay.style.opacity = '0.5'; 
            }
        }

        function mergeTextBlocks(blocks) {
            if (!blocks || blocks.length === 0) return [];
            let merged = JSON.parse(JSON.stringify(blocks));
            for (let i = 0; i < merged.length - 1; i++) {
                let curr = merged[i];
                let next = merged[i+1];
                let currBottom = curr.box_2d[2];
                let nextTop = next.box_2d[0];
                let dist = Math.abs(nextTop - currBottom);
                let xDiff = Math.abs(curr.box_2d[1] - next.box_2d[1]);
                if (dist < 35 && xDiff < 50 && curr.font_size === next.font_size) {
                    curr.text += " " + next.text;
                    curr.box_2d[2] = next.box_2d[2]; 
                    curr.box_2d[3] = Math.max(curr.box_2d[3], next.box_2d[3]); 
                    merged.splice(i+1, 1); 
                    i--; 
                }
            }
            return merged;
        }

        function toggleMerge() {
            if (currentIndex !== -1) renderPageWithZoom(pdfPages[currentIndex]);
        }

        function renderTextOverlay() {
            textOverlay.innerHTML = '';
            const item = pdfPages[currentIndex];
            if (!item.displayData) return;

            item.displayData.forEach((block, idx) => {
                if (!block.box_2d) return;
                const div = document.createElement('div');
                const state = item.blockStates[idx] || 0; 
                let cssClass = 'keep'; 
                let title = 'ç‹€æ…‹ï¼šç¶ æ¡† (ä¿ç•™åŸåœ–)';
                if (state === 1) { cssClass = 'mask-text'; title = 'ç‹€æ…‹ï¼šç´…æ¡† (é®è“‹+è²¼å­—)'; }
                else if (state === 2) { cssClass = 'text-only'; title = 'ç‹€æ…‹ï¼šè—æ¡† (åƒ…è²¼å­—)'; }
                div.className = `ocr-box ${cssClass}`;
                
                const y = block.box_2d[0] / 10;
                const x = block.box_2d[1] / 10;
                const h = (block.box_2d[2] - block.box_2d[0]) / 10;
                const w = (block.box_2d[3] - block.box_2d[1]) / 10;
                
                div.style.top = `${y}%`; div.style.left = `${x}%`; div.style.width = `${w}%`; div.style.height = `${h}%`;
                div.title = title;
                div.onclick = (e) => {
                    if(editMode !== 'select') return;
                    e.stopPropagation();
                    toggleBlockState(idx);
                };
                textOverlay.appendChild(div);
            });
        }

        function toggleBlockState(blockIdx) {
            const item = pdfPages[currentIndex];
            const currentState = item.blockStates[blockIdx] || 0;
            const nextState = (currentState + 1) % 3;
            item.blockStates[blockIdx] = nextState;
            renderTextOverlay();
        }

        async function analyzeCurrentPage() {
            const key = apiKeyInput.value.trim();
            if (!key) return alert('è«‹è¼¸å…¥ API Key');
            canvasLoader.classList.remove('hidden');
            loaderText.textContent = "AI åˆ†ææ’ç‰ˆä¸­...";
            try {
                const base64 = pdfCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                const prompt = `Analyze document layout. Identify all text blocks with TIGHT bounding boxes.
                Return JSON Array ONLY. No markdown.
                [{"text": "content", "box_2d": [ymin, xmin, ymax, xmax] (0-1000), "font_size": 12, "color": "hex", "is_bold": boolean, "align": "left"}]`;

                let result = null;
                for (const model of MODELS) {
                    try {
                        console.log("Trying model:", model);
                        result = await callGemini(key, model, prompt, base64);
                        break; 
                    } catch (e) { console.warn(`Model ${model} failed:`, e); }
                }
                if (!result) throw new Error("AI ç„¡å›æ‡‰");
                const item = pdfPages[currentIndex];
                item.rawData = result;
                item.displayData = result; 
                item.blockStates = new Array(result.length).fill(0); 
                renderPageWithZoom(item);
                updateStatus('success');
                setMode('select');
            } catch (e) {
                alert('åˆ†æå¤±æ•—: ' + e.message);
                updateStatus('error');
            } finally { canvasLoader.classList.add('hidden'); }
        }

        async function callGemini(key, model, text, imageBase64) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${key}`;
            const payload = {
                contents: [{ role: "user", parts: [{ text: text }, { inlineData: { mimeType: "image/jpeg", data: imageBase64 } }] }],
                generationConfig: { responseMimeType: "application/json" }
            };
            const res = await fetch(url, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error?.message);
            try {
                let raw = data.candidates[0].content.parts[0].text;
                raw = raw.replace(/```json/g, '').replace(/```/g, '');
                return JSON.parse(raw);
            } catch(e) { throw new Error('JSON Parse Error'); }
        }

        function clearMask() {
            if(currentIndex !== -1) {
                pdfPages[currentIndex].strokes = [];
                redrawStrokes(pdfPages[currentIndex]);
            }
            checkAllDone();
        }

        function updateStatus(state) {
            const statusDiv = document.getElementById('statusText');
            if (!pdfPages[currentIndex]) return;
            const itemBadge = pdfPages[currentIndex].el.querySelector('.status-badge');
            if (state === 'success') {
                if(itemBadge) { itemBadge.textContent = 'å®Œæˆ'; itemBadge.className = 'status-badge text-[10px] bg-green-100 text-green-600 px-2 py-1 rounded-full inline-block'; }
                const count = pdfPages[currentIndex].displayData ? pdfPages[currentIndex].displayData.length : 0;
                if(statusDiv) statusDiv.textContent = `âœ… åµæ¸¬åˆ° ${count} å€‹å€å¡Š (ç¶ /ç´…/è— åˆ‡æ›)`;
            } else if (state === 'error') {
                if(itemBadge) { itemBadge.textContent = 'å¤±æ•—'; itemBadge.className = 'status-badge text-[10px] bg-red-100 text-red-600 px-2 py-1 rounded-full inline-block'; }
            }
            checkAllDone();
        }

        function checkAllDone() {
            const hasData = pdfPages.some(p => p.rawData || (p.strokes && p.strokes.length > 0));
            document.getElementById('downloadBtn').disabled = !hasData;
        }

        async function startAutoRun() {
            const key = apiKeyInput.value.trim();
            if (!key) return alert('è«‹è¼¸å…¥ API Key');
            for (let i = 0; i < pdfPages.length; i++) {
                if (pdfPages[i].data) continue;
                await loadPage(i);
                await analyzeCurrentPage();
                await new Promise(r => setTimeout(r, 2000));
            }
            alert('æ‰¹æ¬¡è™•ç†å®Œæˆï¼');
        }
        
        function getFontForLanguage(text) {
            if (/[\u4e00-\u9fa5]/.test(text)) return "Noto Sans TC"; 
            return "Google Sans"; 
        }

        async function exportPPT() {
            const btn = document.getElementById('downloadBtn');
            btn.disabled = true; btn.textContent = 'ç”Ÿæˆä¸­...';
            
            const pptx = new PptxGenJS();
            pptx.layout = 'LAYOUT_16x9';
            const maskColorHex = maskColorInput.value.replace('#', '');
            const slideWidth = 10;
            const slideHeight = 5.625;
            const slideRatio = slideWidth / slideHeight;

            for (let i = 0; i < pdfPages.length; i++) {
                const page = pdfPages[i];
                if (!page.displayData && (!page.strokes || page.strokes.length === 0)) continue;
                
                const slide = pptx.addSlide();

                // 1. Background
                let bgData = null;
                try {
                    const pdfPage = await pdfDoc.getPage(page.pageNum);
                    const viewport = pdfPage.getViewport({ scale: 3.0 }); 
                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width; canvas.height = viewport.height;
                    await pdfPage.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                    bgData = canvas.toDataURL('image/jpeg', 1.0);
                } catch(e) { bgData = page.thumb; }

                const imgRatio = page.viewport.width / page.viewport.height;
                let finalW, finalH, finalX, finalY;
                if (imgRatio > slideRatio) {
                    finalW = slideWidth; finalH = slideWidth / imgRatio; finalX = 0; finalY = (slideHeight - finalH) / 2;
                } else {
                    finalH = slideHeight; finalW = slideHeight * imgRatio; finalY = 0; finalX = (slideWidth - finalW) / 2;
                }
                slide.addImage({ data: bgData, x: finalX, y: finalY, w: finalW, h: finalH });

                // 2. Brush Mask (Export using Normalized Coords)
                if (page.strokes && page.strokes.length > 0) {
                    const tempC = document.createElement('canvas');
                    // Create high-res canvas for export to match BG quality
                    const w = 1920; 
                    const h = w / imgRatio;
                    tempC.width = w;
                    tempC.height = h;
                    const tCtx = tempC.getContext('2d');
                    
                    page.strokes.forEach(stroke => {
                        if(stroke.points.length < 1) return;
                        tCtx.beginPath();
                        tCtx.lineCap = 'round';
                        tCtx.lineJoin = 'round';
                        // Denormalize size
                        tCtx.lineWidth = stroke.normSize * w; 
                        tCtx.strokeStyle = stroke.color;
                        
                        // Denormalize points
                        tCtx.moveTo(stroke.points[0].x * w, stroke.points[0].y * h);
                        for(let k=1; k<stroke.points.length; k++) {
                            tCtx.lineTo(stroke.points[k].x * w, stroke.points[k].y * h);
                        }
                        tCtx.stroke();
                    });
                    slide.addImage({ data: tempC.toDataURL(), x: finalX, y: finalY, w: finalW, h: finalH });
                }

                // 3. Text
                if (page.displayData) {
                    page.displayData.forEach((block, idx) => {
                        const state = page.blockStates ? page.blockStates[idx] : 0;
                        const isReconstruct = page.reconstructIndices && page.reconstructIndices.includes(idx);
                        if (!isReconstruct && state === 0) return; 
                        if (!block.box_2d || block.box_2d.length < 4) return;

                        const relX = block.box_2d[1] / 1000;
                        const relY = block.box_2d[0] / 1000;
                        const relW = (block.box_2d[3] - block.box_2d[1]) / 1000;
                        const relH = (block.box_2d[2] - block.box_2d[0]) / 1000;

                        const pptX = finalX + (relX * finalW);
                        const pptY = finalY + (relY * finalH);
                        const pptW = relW * finalW;
                        const pptH = relH * finalH;

                        if (state === 1 || isReconstruct) {
                            const padX = pptW * 0.05;
                            const padY = pptH * 0.05;
                            slide.addShape(pptx.ShapeType.rect, {
                                x: pptX - padX, y: pptY - padY, w: pptW + (padX*2), h: pptH + (padY*2),
                                fill: { color: maskColorHex }, line: { width: 0 } 
                            });
                        }
                        
                        let fontColor = '000000';
                        if (block.color && typeof block.color === 'string') {
                            const safeHex = block.color.replace('#', '').replace(/[^0-9A-Fa-f]/g, '');
                            if (safeHex.length === 6) fontColor = safeHex;
                        }

                        let fontSize = typeof block.font_size === 'number' ? block.font_size : 12;
                        if (fontSize > 100) fontSize = 24; 
                        fontSize = Math.max(fontSize * 0.03, 8); 

                        slide.addText(block.text || "", {
                            x: pptX, y: pptY, w: pptW, h: pptH,
                            fontSize: fontSize,
                            color: fontColor,
                            bold: block.is_bold || false,
                            align: block.align || 'left',
                            valign: 'top',
                            fontFace: getFontForLanguage(block.text) 
                        });
                    });
                }
            }
            
            try {
                await pptx.writeFile({ fileName: 'NotebookLM_V36_4_Fixed.pptx' });
            } catch (err) {
                console.error(err);
                alert("åŒ¯å‡ºéŒ¯èª¤");
            }
            btn.disabled = false; btn.innerHTML = '<i data-lucide="download" class="w-4 h-4"></i> <span class="hidden sm:inline">ä¸‹è¼‰ PPT</span>';
            lucide.createIcons({ root: btn });
        }
    </script>
</body>
</html>
