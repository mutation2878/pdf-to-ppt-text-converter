<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>NotebookLM è½‰ PPT (V37.23 è‡ªå‹•è¼ªè©¢é˜²å‘†ç‰ˆ)</title>
    
    <link rel="manifest" href="manifest.json">
    <script>
      const APP_VERSION = 'V37.23';

      // 1. Service Worker è¨»å†Šèˆ‡ç›£è½
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js').then(reg => {
                console.log('SW registered');
                reg.update(); // å˜—è©¦è§¸ç™¼æ›´æ–°
                
                // ç›£è½ SW æ›´æ–°ç‹€æ…‹
                reg.onupdatefound = () => {
                    const installingWorker = reg.installing;
                    if (installingWorker == null) return;
                    installingWorker.onstatechange = () => {
                        if (installingWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            showUpdatePrompt();
                        }
                    };
                };
            }).catch(err => console.log('SW Skip:', err));
        });
      }

      // 2. é¡¯ç¤ºæ›´æ–°æç¤º (UI)
      function showUpdatePrompt() {
          const div = document.createElement('div');
          div.style.cssText = "position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:#333; color:white; padding:15px 25px; border-radius:30px; box-shadow:0 4px 12px rgba(0,0,0,0.3); z-index:9999; display:flex; align-items:center; gap:15px; font-size:14px; font-weight:bold;";
          div.innerHTML = `
            <span>ğŸš€ æª¢æ¸¬åˆ°æ–°ç‰ˆæœ¬ï¼</span>
            <button onclick="forceUpdate()" style="background:#2563eb; color:white; border:none; padding:5px 15px; border-radius:20px; font-weight:bold;">ç«‹å³æ›´æ–°</button>
          `;
          document.body.appendChild(div);
      }

      // 3. å¼·åˆ¶æ›´æ–°é‚è¼¯ (æ ¸å½ˆç´šæ¸…é™¤)
      async function forceUpdate() {
          if ('serviceWorker' in navigator) {
              const registrations = await navigator.serviceWorker.getRegistrations();
              for (const registration of registrations) {
                  await registration.unregister();
              }
          }
          if ('caches' in window) {
              const keys = await caches.keys();
              await Promise.all(keys.map(key => caches.delete(key)));
          }
          window.location.reload(true);
      }

      // 4. å®šæ™‚æª¢æŸ¥æ©Ÿåˆ¶ (æ¯60ç§’æª¢æŸ¥ä¸€æ¬¡)
      // é€™æ˜¯ç‚ºäº†ç¹é SWï¼Œç›´æ¥ç¢ºèªé€£ç·šä¸¦å˜—è©¦è§¸ç™¼æ›´æ–°
      setInterval(() => {
          if ('serviceWorker' in navigator) {
              navigator.serviceWorker.ready.then(reg => reg.update());
          }
      }, 60000);

    </script>
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        body { font-family: 'Noto Sans TC', 'Microsoft JhengHei', sans-serif; background-color: #f3f4f6; height: 100vh; overflow: hidden; }
        
        /* Version Watermark */
        .version-watermark {
            position: fixed;
            bottom: 5px;
            right: 5px;
            font-size: 10px;
            color: rgba(0,0,0,0.2);
            pointer-events: none;
            z-index: 0;
        }

        /* Responsive Page Card */
        .page-card { 
            transition: all 0.2s; 
            border: 2px solid transparent; 
            cursor: pointer; 
            width: 100%; 
        }
        .page-card:hover { transform: translateY(-2px); }
        .page-card.active { border-color: #2563eb; background-color: #eff6ff; }
        .page-card.done { border-color: #10b981; }

        canvas { touch-action: none; }
        .cursor-pipette { cursor: crosshair !important; }

        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #cbd5e1; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-track { background-color: transparent; }

        /* Slider */
        input[type="range"] {
            -webkit-appearance: none; appearance: none;
            background: #cbd5e1; border-radius: 5px; outline: none; height: 6px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px;
            border-radius: 50%; background: #2563eb; cursor: pointer;
            border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* Checkbox */
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }

        /* OCR Box Styling */
        .ocr-box { 
            position: absolute; 
            z-index: 40; 
            border-radius: 2px; 
            font-family: 'Noto Sans TC', sans-serif;
            font-size: 12px;
            overflow: hidden;
            padding: 1px;
            line-height: 1.2;
            cursor: pointer; 
        }
        
        /* Manual Box */
        .ocr-box.manual {
            background-color: rgba(255, 255, 255, 0.8) !important;
            color: black !important;
            border: 1px solid #666;
            cursor: text; 
            overflow: visible; 
            white-space: normal;
        }

        /* AI Box (No Text) */
        .ocr-box.ai { color: transparent; }
        
        .click-through .ocr-box { pointer-events: none !important; }

        /* Selected State */
        .ocr-box.selected {
            border: 2px solid #2563eb !important; 
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.3);
            z-index: 60;
        }
        
        /* Handles */
        .resize-handle {
            position: absolute; width: 12px; height: 12px;
            background-color: #2563eb; border: 2px solid white;
            bottom: -6px; right: -6px; cursor: se-resize;
            border-radius: 50%; display: none; z-index: 61;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .ocr-box.selected .resize-handle { display: block; }

        .move-handle {
            position: absolute; width: 24px; height: 24px;
            background-color: #2563eb; top: -12px; left: 50%; transform: translateX(-50%);
            cursor: move; border-radius: 4px; display: none; 
            align-items: center; justify-content: center; z-index: 62;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .move-handle::after { content: '+'; color: white; font-size: 18px; font-weight: bold; line-height: 1; }
        .ocr-box.manual.selected .move-handle { display: flex; }

        .delete-handle {
            position: absolute; width: 20px; height: 20px;
            background-color: #ef4444; top: -10px; right: -10px;
            cursor: pointer; border-radius: 50%; display: none;
            align-items: center; justify-content: center; z-index: 63;
            border: 2px solid white; box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .delete-handle::after { content: 'Ã—'; color: white; font-size: 14px; font-weight: bold; line-height: 1; }
        .ocr-box.manual.selected .delete-handle { display: flex; }

        .ocr-box.keep { border: 1px solid #22c55e; background-color: rgba(34, 197, 94, 0.1); }
        .ocr-box.reconstruct { border: 2px solid #ef4444; background-color: rgba(239, 68, 68, 0.15); }
        .ocr-box.overlay { border: 1px dashed #3b82f6; background-color: rgba(59, 130, 246, 0.1); }

        .loader {
            border: 3px solid #e5e7eb; border-top: 3px solid #2563eb; border-radius: 50%;
            width: 24px; height: 24px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        @media (max-width: 640px) {
            .page-card { padding: 0.5rem; }
            .ocr-box { border-width: 1px; } 
            #sidebar { width: 80px; } 
            #sidebar .page-info { display: none; } 
            #toolbar { overflow-x: auto; -webkit-overflow-scrolling: touch; }
        }
    </style>
</head>
<body class="flex flex-col text-slate-800 h-screen w-full overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-sm z-30 p-2 sm:p-3 flex justify-between items-center shrink-0 h-14 sm:h-16 relative w-full">
        <div class="flex items-center gap-2">
            <div class="bg-indigo-600 text-white p-1 sm:p-1.5 rounded-lg font-bold text-lg sm:text-xl">V37.23</div>
            <div class="flex flex-col">
                <h1 class="text-base sm:text-lg font-bold leading-tight hidden sm:block">AI è¦–è¦ºé‡ç¹ªç‰ˆ</h1>
                <span class="text-[10px] text-slate-500 font-bold hidden sm:block">éŸ¿æ‡‰å¼ + è‡ªå‹•æ›´æ–°ä¿®å¾©</span>
            </div>
        </div>
        
        <div class="flex items-center gap-2 sm:gap-3">
            <div class="flex flex-col items-end">
                <input type="password" id="apiKey" class="border rounded px-2 py-1 text-xs sm:text-sm w-24 sm:w-64 focus:border-indigo-500 outline-none transition" placeholder="Gemini API Key">
            </div>
            
            <label class="bg-slate-800 hover:bg-slate-900 text-white px-2 sm:px-3 py-1.5 sm:py-2 rounded cursor-pointer flex items-center gap-2 text-xs sm:text-sm shadow transition">
                <i data-lucide="folder-open" class="w-4 h-4"></i> <span class="hidden sm:inline">é–‹å•Ÿ PDF/PPTX</span>
                <input type="file" id="fileInput" accept=".pdf,.pptx" class="hidden">
            </label>
            
            <!-- Manual Force Update Button -->
            <button onclick="forceUpdate()" class="bg-red-50 hover:bg-red-100 text-red-600 px-2 sm:px-3 py-1.5 sm:py-2 rounded flex items-center gap-2 text-xs sm:text-sm shadow transition border border-red-200" title="å¼·åˆ¶æ¸…é™¤å¿«å–ä¸¦æ›´æ–°">
                <i data-lucide="refresh-cw" class="w-4 h-4"></i>
            </button>
            
            <button id="downloadBtn" onclick="exportPPT()" class="bg-emerald-600 hover:bg-emerald-700 text-white px-2 sm:px-3 py-1.5 sm:py-2 rounded flex items-center gap-2 text-xs sm:text-sm shadow disabled:opacity-50 disabled:cursor-not-allowed transition" disabled>
                <i data-lucide="download" class="w-4 h-4"></i> <span class="hidden sm:inline">ä¸‹è¼‰ PPT</span>
            </button>
        </div>
    </header>

    <!-- Main -->
    <div class="flex flex-1 overflow-hidden relative w-full">
        
        <!-- Left Sidebar -->
        <div id="sidebar" class="w-20 sm:w-64 bg-white border-r flex flex-col shrink-0 z-20 shadow-sm transition-all duration-300">
            <div class="p-2 sm:p-3 border-b bg-slate-50 flex justify-between items-center flex-wrap gap-1">
                <span id="pageCount" class="font-bold text-slate-600 text-[10px] sm:text-xs">ç­‰å¾…æª”æ¡ˆ...</span>
                <button id="autoRunBtn" onclick="startAutoRun()" class="hidden text-indigo-600 text-[10px] sm:text-xs font-bold hover:underline">
                    å…¨éƒ¨åˆ†æ
                </button>
            </div>
            <div id="pagesList" class="flex-1 overflow-y-auto p-2 sm:p-3 space-y-2 sm:space-y-3 bg-slate-50 custom-scrollbar">
                <div class="text-center text-slate-400 text-xs mt-10">
                    <i data-lucide="file-up" class="w-6 h-6 sm:w-8 sm:h-8 mx-auto mb-2 opacity-50"></i>
                    <span class="hidden sm:inline">è«‹ä¸Šå‚³ PDF æˆ– PPTX</span>
                </div>
            </div>
        </div>

        <!-- Right Editor -->
        <div class="flex-1 bg-slate-100 relative flex flex-col h-full overflow-hidden min-w-0">
            
            <!-- Toolbar -->
            <div id="toolbar" class="hidden bg-white p-2 shadow-sm border-b flex items-center gap-2 sm:gap-4 shrink-0 z-20 overflow-x-auto custom-scrollbar w-full whitespace-nowrap">
                
                <div class="flex items-center gap-2 shrink-0">
                     <div class="flex items-center gap-1 bg-slate-100 p-1 rounded-lg border border-slate-200">
                        <button onclick="changeZoom(-0.2)" class="p-1.5 rounded hover:bg-white transition text-slate-600"><i data-lucide="minus" class="w-4 h-4"></i></button>
                        <span id="zoomLabel" class="text-xs font-bold w-8 sm:w-10 text-center select-none">100%</span>
                        <button onclick="changeZoom(0.2)" class="p-1.5 rounded hover:bg-white transition text-slate-600"><i data-lucide="plus" class="w-4 h-4"></i></button>
                    </div>

                    <div class="flex items-center gap-1 bg-slate-100 p-1 rounded-lg border border-slate-200">
                        <button onclick="setMode('select')" id="btn-mode-select" class="px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition bg-white shadow text-indigo-700" title="é¸å–/æ‰‹å‹•èª¿æ•´æ¨¡å¼">
                            <i data-lucide="mouse-pointer-2" class="w-4 h-4"></i>
                        </button>
                        <button onclick="setMode('brush')" id="btn-mode-brush" class="px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition text-slate-500 hover:text-slate-700" title="å¡—é´‰/æ‰‹å‹•é®è“‹æ¨¡å¼">
                            <i data-lucide="brush" class="w-4 h-4"></i>
                        </button>
                    </div>
                    
                    <label class="flex items-center gap-2 cursor-pointer bg-slate-50 border px-2 py-1.5 rounded-lg hover:bg-slate-100 transition select-none ml-2" title="è‡ªå‹•åˆä½µç›¸é„°çš„æ–‡å­—æ®µè½">
                        <input type="checkbox" id="mergeToggle" class="rounded text-indigo-600 focus:ring-indigo-500 w-4 h-4" onchange="toggleMerge()" checked>
                        <span class="text-xs font-bold text-slate-700 hidden sm:inline"><i data-lucide="merge" class="w-3 h-3 inline mr-1"></i>åˆä½µ</span>
                        <span class="text-xs font-bold text-slate-700 sm:hidden"><i data-lucide="merge" class="w-3 h-3"></i></span>
                    </label>
                </div>

                <div class="flex items-center gap-2 sm:gap-3 shrink-0">
                    <button onclick="analyzeCurrentPage()" class="bg-indigo-50 text-indigo-700 px-2 sm:px-3 py-1.5 rounded-lg text-xs font-bold flex items-center gap-2 hover:bg-indigo-100 transition border border-indigo-200 shadow-sm whitespace-nowrap">
                        <i data-lucide="scan-eye" class="w-4 h-4"></i> <span class="hidden sm:inline">AI è¾¨è­˜</span>
                    </button>

                    <button onclick="addTextBox()" class="bg-emerald-50 text-emerald-700 px-2 sm:px-3 py-1.5 rounded-lg text-xs font-bold flex items-center gap-2 hover:bg-emerald-100 transition border border-emerald-200 shadow-sm whitespace-nowrap" title="æ‰‹å‹•æ–°å¢æ–‡å­—æ¡†">
                        <i data-lucide="plus-square" class="w-4 h-4"></i> <span class="hidden sm:inline">æ–°å¢æ¡†</span>
                    </button>

                    <div class="flex items-center gap-2 border-l pl-2 sm:pl-3 bg-slate-50 p-1 rounded-lg border border-slate-200">
                        <button id="eyedropperBtn" onclick="toggleEyedropper()" class="p-1.5 border rounded bg-white hover:bg-slate-100 text-slate-600 transition shadow-sm" title="å¸å–èƒŒæ™¯è‰² (ç”¨æ–¼é®è“‹)">
                            <i data-lucide="pipette" class="w-4 h-4"></i>
                        </button>
                        <div class="relative w-8 h-8 rounded border overflow-hidden shadow-sm cursor-pointer hover:scale-105 transition" title="é»æ“Šé¸æ“‡é®ç½©é¡è‰² (æœƒè‡ªå‹•åµæ¸¬)">
                             <input type="color" id="maskColor" value="#FFFFFF" class="absolute -top-2 -left-2 w-16 h-16 p-0 border-0 cursor-pointer">
                        </div>
                        
                        <div class="w-px h-4 bg-slate-300 mx-1"></div>
                        
                        <div class="flex flex-col justify-center px-1">
                             <span class="text-[9px] text-slate-400 font-bold mb-0.5 whitespace-nowrap">å­—é«”: <span id="fontScaleVal">1.0</span>x</span>
                             <input type="range" id="fontScale" min="0.5" max="1.5" step="0.1" value="1.0" class="w-16 sm:w-20" oninput="document.getElementById('fontScaleVal').textContent=this.value">
                        </div>

                        <div class="flex flex-col justify-center px-1 border-l pl-2 ml-1">
                             <span class="text-[9px] text-red-400 font-bold mb-0.5 whitespace-nowrap">æ“´å¼µ: <span id="maskExpVal">1.2</span>x</span>
                             <input type="range" id="maskExpansion" min="0.0" max="2.0" step="0.1" value="1.2" class="w-16 sm:w-20" oninput="document.getElementById('maskExpVal').textContent=this.value">
                        </div>

                        <div class="w-px h-4 bg-slate-300 mx-1"></div>

                        <button onclick="undoLastStroke()" class="text-slate-500 hover:text-indigo-600 p-1.5 transition border rounded bg-white shadow-sm" title="å¾©åŸä¸Šä¸€ç­†">
                            <i data-lucide="undo-2" class="w-4 h-4"></i>
                        </button>
                        <button onclick="clearMask()" class="text-slate-400 hover:text-red-500 p-1.5 transition" title="æ¸…é™¤æ‰€æœ‰å¡—é´‰">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Preview Area -->
            <div id="previewArea" class="flex-1 overflow-auto bg-slate-200 relative hidden p-2 sm:p-8 custom-scrollbar flex flex-col items-center w-full">
                <div id="canvasContainer" class="relative shadow-2xl bg-white hidden flex-shrink-0 m-auto" style="width: 0; height: 0;">
                    <canvas id="pdfCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>
                    <canvas id="maskCanvas" class="absolute top-0 left-0 w-full h-full z-20 cursor-crosshair touch-none"></canvas>
                    <div id="textOverlay" class="absolute top-0 left-0 w-full h-full z-30 pointer-events-none"></div>

                    <div id="canvasLoader" class="absolute inset-0 bg-white/90 z-50 hidden flex flex-col items-center justify-center backdrop-blur-sm">
                        <div class="loader mb-3"></div>
                        <span class="text-sm font-bold text-slate-600 animate-pulse" id="loaderText">AI è¦–è¦ºé‹ç®—ä¸­...</span>
                    </div>
                </div>
            </div>

            <div id="emptyState" class="flex-1 flex flex-col items-center justify-center text-slate-400">
                <i data-lucide="image-plus" class="w-12 h-12 sm:w-16 sm:h-16 mb-4 opacity-20"></i>
                <p class="text-xs sm:text-sm font-bold opacity-60">è«‹å…ˆä¸Šå‚³æª”æ¡ˆ</p>
            </div>
            
            <div class="bg-white border-t p-2 px-4 flex justify-between items-center text-[10px] sm:text-xs text-slate-500 shrink-0 z-20 overflow-x-auto w-full">
                <div id="statusText" class="whitespace-nowrap mr-2">ç­‰å¾…æ“ä½œ</div>
                <div class="font-bold flex gap-2 sm:gap-3 text-[10px] sm:text-xs whitespace-nowrap">
                    <span class="text-green-600">ğŸŸ© ä¿ç•™</span>
                    <span class="text-gray-300">|</span>
                    <span class="text-red-500">ğŸŸ¥ é‡å»º</span>
                    <span class="text-gray-300">|</span>
                    <span class="text-blue-500">ğŸŸ¦ ç–ŠåŠ </span>
                    <span class="text-gray-300">|</span>
                    <span class="text-slate-500">ğŸ–±ï¸ æ‹–æ›³èª¿æ•´</span>
                </div>
            </div>
        </div>
        <!-- Watermark for debugging -->
        <div class="version-watermark">V37.23</div>
    </div>

    <script>
        if (typeof lucide !== 'undefined') lucide.createIcons();

        // --- State ---
        let currentFileMode = 'pdf'; 
        let pdfDoc = null;
        let pptxSlides = [];
        let pagesData = [];
        let currentIndex = -1;
        let editMode = 'select'; 
        let isDrawing = false;
        let isEyedropper = false;
        let zoomLevel = 1.0; 
        
        let selectedBlockIndex = -1;
        let dragAction = null; 
        let dragStart = { x: 0, y: 0 };
        let activeBlockData = null; 
        
        // --- DOM ---
        const apiKeyInput = document.getElementById('apiKey');
        const fileInput = document.getElementById('fileInput');
        const pagesList = document.getElementById('pagesList');
        const previewArea = document.getElementById('previewArea');
        const canvasContainer = document.getElementById('canvasContainer');
        const textOverlay = document.getElementById('textOverlay');
        const emptyState = document.getElementById('emptyState');
        const toolbar = document.getElementById('toolbar');
        const statusTextEl = document.getElementById('statusText'); 
        
        const pdfCanvas = document.getElementById('pdfCanvas');
        const maskCanvas = document.getElementById('maskCanvas');
        const maskCtx = maskCanvas.getContext('2d');
        const canvasLoader = document.getElementById('canvasLoader');
        const zoomLabel = document.getElementById('zoomLabel');
        
        const maskColorInput = document.getElementById('maskColor');
        const eyedropperBtn = document.getElementById('eyedropperBtn');
        const btnModeSelect = document.getElementById('btn-mode-select');
        const btnModeBrush = document.getElementById('btn-mode-brush');
        const mergeToggle = document.getElementById('mergeToggle');
        const fontScaleInput = document.getElementById('fontScale');
        const maskExpansionInput = document.getElementById('maskExpansion');

        // --- File Handling ---
        fileInput.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const ext = file.name.split('.').pop().toLowerCase();

            document.getElementById('pageCount').textContent = 'è®€å–ä¸­...';
            pagesList.innerHTML = '';
            pagesData = [];
            currentIndex = -1;
            selectedBlockIndex = -1;
            emptyState.classList.remove('hidden');
            previewArea.classList.add('hidden');
            toolbar.classList.add('hidden');

            try {
                if (ext === 'pdf') {
                    currentFileMode = 'pdf';
                    await handlePDF(file);
                } else if (ext === 'pptx') {
                    currentFileMode = 'pptx';
                    await handlePPTX(file);
                } else {
                    alert('ä¸æ”¯æ´çš„æ ¼å¼');
                }
            } catch (err) {
                console.error(err);
                alert('æª”æ¡ˆè®€å–å¤±æ•—: ' + err.message);
            }
        };

        async function handlePDF(file) {
            const buffer = await file.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument(new Uint8Array(buffer)).promise;
            document.getElementById('pageCount').textContent = `PDF å…± ${pdfDoc.numPages} é `;
            document.getElementById('autoRunBtn').classList.remove('hidden');
            
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                pagesData.push({
                    pageNum: i,
                    type: 'pdf',
                    rawData: null,
                    displayData: null,
                    blockStates: [],
                    strokes: [],
                    viewport: null,
                    thumbUrl: null
                });
            }
            renderThumbnails();
        }

        async function handlePPTX(file) {
            const zip = new JSZip();
            await zip.loadAsync(file);
            const mediaFolder = zip.folder("ppt/media");
            const imgFiles = [];
            if (mediaFolder) {
                mediaFolder.forEach((relativePath, file) => {
                    if (relativePath.match(/\.(jpg|jpeg|png)$/i)) {
                        imgFiles.push({ path: relativePath, file: file });
                    }
                });
            }
            imgFiles.sort((a, b) => {
                const numA = parseInt(a.path.match(/\d+/)?.[0] || 0);
                const numB = parseInt(b.path.match(/\d+/)?.[0] || 0);
                return numA - numB;
            });
            if (imgFiles.length === 0) throw new Error("æ­¤ PPTX ä¸­æœªç™¼ç¾åœ–ç‰‡");
            document.getElementById('pageCount').textContent = `PPTX åœ–ç‰‡: ${imgFiles.length} å¼µ`;
            document.getElementById('autoRunBtn').classList.remove('hidden');
            pptxSlides = [];
            for (let i = 0; i < imgFiles.length; i++) {
                const blob = await imgFiles[i].file.async("blob");
                const url = URL.createObjectURL(blob);
                pptxSlides.push(url);
                pagesData.push({
                    pageNum: i + 1,
                    type: 'pptx',
                    imgUrl: url,
                    rawData: null,
                    displayData: null,
                    blockStates: [],
                    strokes: [],
                    viewport: null,
                    thumbUrl: null
                });
            }
            renderThumbnails();
        }

        async function renderThumbnails() {
            pagesList.innerHTML = '';
            for (let i = 0; i < pagesData.length; i++) {
                const item = pagesData[i];
                const div = document.createElement('div');
                div.className = 'page-card bg-white p-2 rounded-lg shadow-sm border border-slate-200 flex items-center gap-3 hover:bg-blue-50';
                
                let thumbSrc = '';
                try {
                    if (item.type === 'pdf') {
                        const page = await pdfDoc.getPage(item.pageNum);
                        const vp = page.getViewport({ scale: 0.15 });
                        const cvs = document.createElement('canvas');
                        cvs.width = vp.width; cvs.height = vp.height;
                        await page.render({ canvasContext: cvs.getContext('2d'), viewport: vp }).promise;
                        thumbSrc = cvs.toDataURL();
                        item.viewport = page.getViewport({ scale: 1.0 });
                    } else {
                        thumbSrc = item.imgUrl;
                        const img = new Image();
                        img.src = item.imgUrl;
                        await img.decode();
                        item.viewport = { width: img.naturalWidth, height: img.naturalHeight };
                    }
                } catch(e) { console.error("Thumb error", e); continue; }

                item.thumbUrl = thumbSrc;
                div.innerHTML = `
                    <div class="font-bold text-slate-400 text-xs w-6">${i+1}</div>
                    <img src="${thumbSrc}" class="h-10 w-auto sm:h-12 border border-slate-200 rounded object-contain bg-white">
                    <div class="flex-1 text-right page-info">
                        <div class="status-badge text-[10px] bg-slate-100 text-slate-500 px-2 py-1 rounded-full inline-block">æœªåˆ†æ</div>
                    </div>
                `;
                div.onclick = () => loadPage(i);
                item.el = div;
                pagesList.appendChild(div);
            }
        }

        // --- Editor Logic ---
        async function loadPage(index) {
            currentIndex = index;
            selectedBlockIndex = -1;
            const item = pagesData[index];
            document.querySelectorAll('.page-card').forEach(c => c.classList.remove('active'));
            item.el.classList.add('active');
            emptyState.classList.add('hidden');
            previewArea.classList.remove('hidden');
            toolbar.classList.remove('hidden');
            renderPageWithZoom(item);
        }

        async function renderPageWithZoom(item) {
            try {
                if(!item.viewport) return; 

                // Responsive Canvas Logic
                const isMobile = window.innerWidth < 640;
                // On mobile, use 90% width. On Desktop, use 70% width or fixed ratio.
                const baseW = isMobile ? window.innerWidth * 0.9 : window.innerWidth * 0.7;
                const baseH = isMobile ? window.innerHeight * 0.6 : window.innerHeight * 0.8;
                
                const ratio = item.viewport.width / item.viewport.height;
                let finalW, finalH;
                if (baseW / baseH > ratio) {
                     finalH = baseH * zoomLevel; finalW = finalH * ratio;
                } else {
                     finalW = baseW * zoomLevel; finalH = finalW / ratio;
                }

                canvasContainer.style.width = `${finalW}px`;
                canvasContainer.style.height = `${finalH}px`;
                canvasContainer.classList.remove('hidden');

                const scale = 2.0 * zoomLevel;
                pdfCanvas.width = item.viewport.width * scale; 
                pdfCanvas.height = item.viewport.height * scale;
                maskCanvas.width = pdfCanvas.width;
                maskCanvas.height = pdfCanvas.height;

                const ctx = pdfCanvas.getContext('2d');
                ctx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);

                if (item.type === 'pdf') {
                    const page = await pdfDoc.getPage(item.pageNum);
                    await page.render({ canvasContext: ctx, viewport: page.getViewport({ scale: scale * (item.viewport.width / page.getViewport({scale:1}).width) }) }).promise;
                } else {
                    const img = new Image();
                    img.src = item.imgUrl;
                    await img.decode();
                    ctx.drawImage(img, 0, 0, pdfCanvas.width, pdfCanvas.height);
                }

                autoPickBackgroundColor();
                redrawStrokes(item);
                if (!item.displayData && item.rawData) processData(item);
                renderTextOverlay(item);
                updateStatus(item);
                setMode(editMode);
            } catch (err) {
                console.error("Render Error:", err);
            }
        }
        
        function autoPickBackgroundColor() {
            if (!pdfCanvas) return;
            try {
                const ctx = pdfCanvas.getContext('2d');
                if (pdfCanvas.width > 10) {
                    const p = ctx.getImageData(10, 10, 1, 1).data; 
                    const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
                    maskColorInput.value = hex;
                }
            } catch(e) {}
        }

        function changeZoom(delta) {
            zoomLevel = Math.max(0.5, Math.min(zoomLevel + delta, 3.0));
            zoomLabel.textContent = `${Math.round(zoomLevel * 100)}%`;
            if (currentIndex !== -1) renderPageWithZoom(pagesData[currentIndex]);
        }

        // --- Interaction Handlers ---
        function getNormalizedPoint(e) {
            const rect = maskCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (clientX - rect.left) / rect.width, y: (clientY - rect.top) / rect.height };
        }

        function startDrawing(e) {
            if (isEyedropper) { pickColor(e); return; }
            if (editMode !== 'brush') return;
            isDrawing = true;
            const pt = getNormalizedPoint(e);
            const normSize = 25 / 1000; 
            pagesData[currentIndex].strokes.push({ color: maskColorInput.value, normSize, points: [pt] });
            
            const w = maskCanvas.width; const h = maskCanvas.height;
            maskCtx.beginPath(); maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round';
            maskCtx.lineWidth = normSize * w; maskCtx.strokeStyle = maskColorInput.value;
            maskCtx.moveTo(pt.x * w, pt.y * h); maskCtx.lineTo(pt.x * w, pt.y * h); maskCtx.stroke();
        }

        function draw(e) {
            if (!isDrawing) return;
            const pt = getNormalizedPoint(e);
            const stroke = pagesData[currentIndex].strokes.slice(-1)[0];
            stroke.points.push(pt);
            
            const w = maskCanvas.width; const h = maskCanvas.height;
            const prev = stroke.points[stroke.points.length - 2];
            
            maskCtx.beginPath(); maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round';
            maskCtx.lineWidth = stroke.normSize * w; maskCtx.strokeStyle = stroke.color;
            maskCtx.moveTo(prev.x * w, prev.y * h); maskCtx.lineTo(pt.x * w, pt.y * h); maskCtx.stroke();
        }

        function stopDrawing() { isDrawing = false; checkAllDone(); }

        function redrawStrokes(item) {
            maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
            const w = maskCanvas.width; const h = maskCanvas.height;
            item.strokes.forEach(s => {
                if (s.points.length < 1) return;
                maskCtx.beginPath(); maskCtx.lineCap = 'round'; maskCtx.lineJoin = 'round';
                maskCtx.lineWidth = s.normSize * w; maskCtx.strokeStyle = s.color;
                maskCtx.moveTo(s.points[0].x * w, s.points[0].y * h);
                for (let i=1; i<s.points.length; i++) maskCtx.lineTo(s.points[i].x * w, s.points[i].y * h);
                maskCtx.stroke();
            });
        }

        function undoLastStroke() {
            if (currentIndex === -1) return;
            pagesData[currentIndex].strokes.pop();
            redrawStrokes(pagesData[currentIndex]);
        }
        
        function clearMask() {
            if (currentIndex === -1) return;
            pagesData[currentIndex].strokes = [];
            redrawStrokes(pagesData[currentIndex]);
        }

        function toggleEyedropper() {
            isEyedropper = !isEyedropper;
            eyedropperBtn.classList.toggle('bg-blue-100', isEyedropper);
            maskCanvas.classList.toggle('cursor-pipette', isEyedropper);
            maskCanvas.style.pointerEvents = isEyedropper ? 'auto' : (editMode === 'brush' ? 'auto' : 'none');
            textOverlay.style.pointerEvents = isEyedropper ? 'none' : (editMode === 'select' ? 'auto' : 'none');
        }

        function pickColor(e) {
            const rect = maskCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const scaleX = pdfCanvas.width / rect.width;
            const scaleY = pdfCanvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            
            const p = pdfCanvas.getContext('2d').getImageData(x, y, 1, 1).data;
            const hex = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
            maskColorInput.value = hex;
            toggleEyedropper();
        }

        function setMode(mode) {
            editMode = mode;
            btnModeSelect.className = mode==='select' ? "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition bg-white shadow text-indigo-700" : "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition text-slate-500";
            btnModeBrush.className = mode==='brush' ? "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition bg-white shadow text-indigo-700" : "px-3 py-1.5 rounded-md text-xs font-bold flex items-center gap-1 transition text-slate-500";
            
            maskCanvas.style.pointerEvents = mode === 'brush' ? 'auto' : 'none';
            textOverlay.style.pointerEvents = mode === 'select' ? 'auto' : 'none';
            textOverlay.classList.toggle('click-through', mode !== 'select');
            textOverlay.style.opacity = mode === 'select' ? '1' : '0.4';
            
            if (mode === 'brush') {
                selectedBlockIndex = -1;
                if(currentIndex !== -1) renderTextOverlay(pagesData[currentIndex]);
            }
        }

        // --- Core Logic ---
        function addTextBox() {
            if (currentIndex === -1) {
                alert("è«‹å…ˆä¸Šå‚³ä¸¦é¸æ“‡ä¸€å€‹é é¢");
                return;
            }
            const item = pagesData[currentIndex];
            if (!item.displayData) item.displayData = []; 

            const newBlock = {
                text: "æ–°å¢æ–‡å­—",
                box_2d: [450, 400, 500, 600], 
                font_size: 12,
                color: "#000000",
                is_bold: false,
                align: "left",
                isManual: true 
            };
            
            item.displayData.push(newBlock);
            item.blockStates.push(1); 
            renderTextOverlay(item);
            selectedBlockIndex = item.displayData.length - 1;
            renderTextOverlay(item); 
        }
        
        function deleteBlock(index) {
            const item = pagesData[currentIndex];
            item.displayData.splice(index, 1);
            item.blockStates.splice(index, 1);
            selectedBlockIndex = -1;
            renderTextOverlay(item);
            updateStatus(item);
        }

        function toggleMerge() {
            if (currentIndex !== -1) {
                const item = pagesData[currentIndex];
                processData(item);
                renderTextOverlay(item);
            }
        }

        function processData(item) {
            if (!item.rawData) return;
            const shouldMerge = mergeToggle.checked;
            
            if (shouldMerge) {
                item.displayData = mergeTextBlocks(JSON.parse(JSON.stringify(item.rawData)));
            } else {
                item.displayData = JSON.parse(JSON.stringify(item.rawData));
            }

            if (item.blockStates.length !== item.displayData.length) {
                item.blockStates = new Array(item.displayData.length).fill(1);
            }
        }

        function mergeTextBlocks(blocks) {
            if (!blocks || blocks.length === 0) return [];
            blocks.sort((a, b) => (a.box_2d[0] - b.box_2d[0]) || (a.box_2d[1] - b.box_2d[1]));
            
            let merged = [];
            if(blocks.length > 0) merged.push(blocks[0]);

            for (let i = 1; i < blocks.length; i++) {
                let curr = blocks[i];
                let prev = merged[merged.length - 1];

                let fontSizeMatch = Math.abs((curr.font_size || 0) - (prev.font_size || 0)) < 3;
                let vDist = curr.box_2d[0] - prev.box_2d[2]; 
                let hOverlap = !(curr.box_2d[1] > prev.box_2d[3] || curr.box_2d[3] < prev.box_2d[1]);
                let alignLeft = Math.abs(curr.box_2d[1] - prev.box_2d[1]) < 50; 

                if (fontSizeMatch && vDist < 50 && (hOverlap || alignLeft)) {
                    prev.text += " " + curr.text;
                    prev.box_2d[2] = curr.box_2d[2]; 
                    prev.box_2d[3] = Math.max(prev.box_2d[3], curr.box_2d[3]); 
                    prev.box_2d[1] = Math.min(prev.box_2d[1], curr.box_2d[1]); 
                } else {
                    merged.push(curr);
                }
            }
            return merged;
        }

        // --- Interaction Logic (Fixed V37.19) ---
        function handleOverlayMouseDown(e) {
            if (editMode !== 'select') return;
            const item = pagesData[currentIndex];
            if (!item || !item.displayData) return;

            // Allow clicking inside manual text to edit
            if (e.target.isContentEditable) return;
            
            // Handle Delete click
            if (e.target.classList.contains('delete-handle')) return;

            const rect = textOverlay.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;
            
            // Check Resize Handle
            if (e.target.classList.contains('resize-handle')) {
                dragAction = 'resize';
                dragStart = { x: mouseX, y: mouseY };
                activeBlockData = JSON.parse(JSON.stringify(item.displayData[selectedBlockIndex].box_2d));
                e.stopPropagation();
                return;
            }
            
            // Check Move Handle (Manual Box)
            if (e.target.classList.contains('move-handle')) {
                dragAction = 'move';
                dragStart = { x: mouseX, y: mouseY };
                activeBlockData = JSON.parse(JSON.stringify(item.displayData[selectedBlockIndex].box_2d));
                e.stopPropagation();
                return;
            }

            // Check Box Body (AI Box only)
            const targetBox = e.target.closest('.ocr-box');
            if (targetBox) {
                const children = Array.from(textOverlay.children);
                const idx = children.indexOf(targetBox);
                
                if (idx !== -1) {
                    const block = item.displayData[idx];

                    if (idx === selectedBlockIndex) {
                        // Already selected. 
                        // If it's an AI box (not manual), we allow body drag.
                        if (!block.isManual) {
                            dragAction = 'move';
                            dragStart = { x: mouseX, y: mouseY };
                            activeBlockData = JSON.parse(JSON.stringify(block.box_2d));
                        }
                    } else {
                        // Select new box
                        selectedBlockIndex = idx;
                        renderTextOverlay(item); 
                        
                        // Immediate drag start for AI box
                        if (!block.isManual) {
                            dragAction = 'move';
                            dragStart = { x: mouseX, y: mouseY };
                            activeBlockData = JSON.parse(JSON.stringify(block.box_2d));
                        }
                    }
                    e.stopPropagation();
                }
            } else {
                if (selectedBlockIndex !== -1) {
                    selectedBlockIndex = -1;
                    renderTextOverlay(item);
                }
            }
        }

        function handleOverlayMouseMove(e) {
            if (!dragAction || selectedBlockIndex === -1) return;
            const item = pagesData[currentIndex];
            
            const rect = textOverlay.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            if(!clientX) return; 

            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;
            const deltaX = mouseX - dragStart.x;
            const deltaY = mouseY - dragStart.y;
            
            const scaleX = 1000 / rect.width;
            const scaleY = 1000 / rect.height;
            const dX_1000 = deltaX * scaleX;
            const dY_1000 = deltaY * scaleY;

            const block = item.displayData[selectedBlockIndex];
            const initial = activeBlockData; 

            if (dragAction === 'move') {
                block.box_2d[0] = initial[0] + dY_1000;
                block.box_2d[1] = initial[1] + dX_1000;
                block.box_2d[2] = initial[2] + dY_1000;
                block.box_2d[3] = initial[3] + dX_1000;
            } else if (dragAction === 'resize') {
                block.box_2d[2] = Math.max(block.box_2d[0] + 10, initial[2] + dY_1000);
                block.box_2d[3] = Math.max(block.box_2d[1] + 10, initial[3] + dX_1000);
            }
            
            const div = textOverlay.children[selectedBlockIndex];
            if (div) {
                const y = block.box_2d[0]/10; const x = block.box_2d[1]/10;
                const h = (block.box_2d[2]-block.box_2d[0])/10; const w = (block.box_2d[3]-block.box_2d[1])/10;
                div.style.top = `${y}%`; div.style.left = `${x}%`; div.style.width = `${w}%`; div.style.height = `${h}%`;
            }
            e.preventDefault(); 
        }

        function handleOverlayMouseUp(e) {
            dragAction = null;
            activeBlockData = null;
        }

        function renderTextOverlay(item) {
            textOverlay.innerHTML = '';
            if (!item.displayData) return;
            
            item.displayData.forEach((block, idx) => {
                const div = document.createElement('div');
                const state = item.blockStates[idx] !== undefined ? item.blockStates[idx] : 1;
                let cssClass = 'keep';
                if (state === 1) cssClass = 'reconstruct';
                else if (state === 2) cssClass = 'overlay';

                if (idx === selectedBlockIndex) {
                    div.classList.add('selected');
                }
                
                const isManual = !!block.isManual;
                if (isManual) {
                    div.classList.add('manual');
                    div.setAttribute('contenteditable', 'true');
                    div.textContent = block.text;
                    div.addEventListener('input', () => { block.text = div.textContent; });
                } else {
                    div.classList.add('ai');
                    div.setAttribute('contenteditable', 'false');
                    div.textContent = ""; 
                }

                div.className = `ocr-box ${cssClass} ${idx === selectedBlockIndex ? 'selected' : ''} ${isManual ? 'manual' : 'ai'}`;
                
                const y = block.box_2d[0]/10; const x = block.box_2d[1]/10;
                const h = (block.box_2d[2]-block.box_2d[0])/10; const w = (block.box_2d[3]-block.box_2d[1])/10;
                div.style.top = `${y}%`; div.style.left = `${x}%`; div.style.width = `${w}%`; div.style.height = `${h}%`;
                
                if (idx === selectedBlockIndex) {
                    // Resize Handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.contentEditable = "false";
                    div.appendChild(resizeHandle);
                    
                    // Move Handle (For Manual Boxes)
                    if (isManual) {
                        const moveHandle = document.createElement('div');
                        moveHandle.className = 'move-handle';
                        moveHandle.contentEditable = "false";
                        div.appendChild(moveHandle);
                        
                        const deleteHandle = document.createElement('div');
                        deleteHandle.className = 'delete-handle';
                        deleteHandle.contentEditable = "false";
                        deleteHandle.onclick = (e) => {
                            e.stopPropagation();
                            deleteBlock(idx);
                        };
                        div.appendChild(deleteHandle);
                    }
                }

                div.addEventListener('dblclick', (e) => {
                    if (e.target !== div && isManual) return; 
                    e.stopPropagation();
                    item.blockStates[idx] = (state + 1) % 3;
                    renderTextOverlay(item);
                });

                textOverlay.appendChild(div);
            });
        }
        
        textOverlay.addEventListener('mousedown', handleOverlayMouseDown);
        window.addEventListener('mousemove', handleOverlayMouseMove); 
        window.addEventListener('mouseup', handleOverlayMouseUp);
        
        textOverlay.addEventListener('touchstart', (e)=>{
            if(e.touches.length > 1) return; 
            handleOverlayMouseDown(e);
        }, {passive: false});
        window.addEventListener('touchmove', handleOverlayMouseMove, {passive: false});
        window.addEventListener('touchend', handleOverlayMouseUp);

        async function analyzeCurrentPage() {
            const key = apiKeyInput.value.trim();
            if (!key) return alert('è«‹è¼¸å…¥ API Key');
            canvasLoader.classList.remove('hidden');
            
            try {
                const base64 = pdfCanvas.toDataURL('image/jpeg', 0.8).split(',')[1];
                const prompt = `Identify all text blocks for RECONSTRUCTION. Return JSON Array ONLY.
Format: [{"text": "content", "box_2d": [ymin, xmin, ymax, xmax] (0-1000 scale), "font_size": number, "color": "hex", "is_bold": boolean, "align": "left"}]
Important: The box_2d MUST include the full background context of the text, not just the glyphs. It should cover line spacing and margin to ensure clean removal.`;

                const result = await callGemini(key, prompt, base64);
                const item = pagesData[currentIndex];
                item.rawData = result;
                
                processData(item);
                item.blockStates = new Array(item.displayData.length).fill(1); 
                autoPickBackgroundColor();
                renderTextOverlay(item);
                updateStatus(item);
            } catch (e) {
                alert('AI åˆ†æå¤±æ•—: ' + e.message);
                updateStatus(pagesData[currentIndex]);
            } finally {
                canvasLoader.classList.add('hidden');
            }
        }

        async function callGemini(key, text, imageBase64) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`;
            const payload = {
                contents: [{ role: "user", parts: [{ text: text }, { inlineData: { mimeType: "image/jpeg", data: imageBase64 } }] }],
                generationConfig: { responseMimeType: "application/json" }
            };
            const res = await fetch(url, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
            const data = await res.json();
            if (!res.ok) throw new Error(data.error?.message || 'API Error');
            const raw = data.candidates[0].content.parts[0].text.replace(/```json/g, '').replace(/```/g, '');
            return JSON.parse(raw);
        }

        function updateStatus(item) {
            const badge = item.el.querySelector('.status-badge');
            if (item.rawData) {
                badge.textContent = 'å·²åˆ†æ';
                badge.className = 'status-badge text-[10px] bg-indigo-100 text-indigo-600 px-2 py-1 rounded-full inline-block';
                statusTextEl.textContent = `âœ… åµæ¸¬åˆ° ${item.displayData.length} å€‹å€å¡Š`;
            } else {
                badge.textContent = 'æœªåˆ†æ';
                statusTextEl.textContent = 'è«‹é»æ“Šã€ŒAI è¦–è¦ºè¾¨è­˜ã€';
            }
            checkAllDone();
        }

        function checkAllDone() {
            const ready = pagesData.some(p => p.rawData || p.strokes.length > 0);
            document.getElementById('downloadBtn').disabled = !ready;
        }

        async function startAutoRun() {
            const key = apiKeyInput.value.trim();
            if (!key) return alert('è«‹è¼¸å…¥ API Key');
            for (let i = 0; i < pagesData.length; i++) {
                if (pagesData[i].rawData) continue;
                await loadPage(i);
                await analyzeCurrentPage();
                await new Promise(r => setTimeout(r, 1500)); 
            }
            alert('å…¨éƒ¨åˆ†æå®Œæˆï¼');
        }

        async function exportPPT() {
            const btn = document.getElementById('downloadBtn');
            btn.disabled = true; btn.textContent = 'ç”Ÿæˆä¸­...';
            
            const userFontScale = parseFloat(fontScaleInput.value) || 1.0;
            const maskExpansion = parseFloat(maskExpansionInput.value) || 1.2;

            try {
                const pptx = new PptxGenJS();
                pptx.layout = 'LAYOUT_16x9';

                for (let i = 0; i < pagesData.length; i++) {
                    const item = pagesData[i];
                    const slide = pptx.addSlide();

                    const tempCanvas = document.createElement('canvas');
                    const vpW = item.viewport?.width || 1024;
                    const vpH = item.viewport?.height || 768;
                    const exportScale = 2000 / vpW; 
                    tempCanvas.width = vpW * exportScale;
                    tempCanvas.height = vpH * exportScale;
                    const ctx = tempCanvas.getContext('2d');

                    if (item.type === 'pdf') {
                        const page = await pdfDoc.getPage(item.pageNum);
                        await page.render({ canvasContext: ctx, viewport: page.getViewport({ scale: exportScale }) }).promise;
                    } else {
                        const img = new Image(); img.src = item.imgUrl; await img.decode();
                        ctx.drawImage(img, 0, 0, tempCanvas.width, tempCanvas.height);
                    }

                    const maskHex = maskColorInput.value;
                    if (item.displayData) {
                        item.displayData.forEach((block, idx) => {
                            if (item.blockStates[idx] === 1) { 
                                const y = (block.box_2d[0] / 1000) * tempCanvas.height;
                                const x = (block.box_2d[1] / 1000) * tempCanvas.width;
                                const h = ((block.box_2d[2] - block.box_2d[0]) / 1000) * tempCanvas.height;
                                const w = ((block.box_2d[3] - block.box_2d[1]) / 1000) * tempCanvas.width;
                                
                                const expFactor = maskExpansion - 1.0; 
                                let paddingH = 0;
                                let paddingW = 0;
                                if (expFactor > 0) {
                                    paddingH = h * expFactor;
                                    paddingW = w * expFactor;
                                }
                                
                                ctx.fillStyle = maskHex; 
                                ctx.fillRect(x - paddingW, y - paddingH, w + (paddingW * 2), h + (paddingH * 2));
                            }
                        });
                    }

                    item.strokes.forEach(s => {
                        if (s.points.length < 1) return;
                        ctx.beginPath(); ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                        ctx.lineWidth = s.normSize * tempCanvas.width; ctx.strokeStyle = s.color;
                        ctx.moveTo(s.points[0].x * tempCanvas.width, s.points[0].y * tempCanvas.height);
                        for(let k=1; k<s.points.length; k++) ctx.lineTo(s.points[k].x * tempCanvas.width, s.points[k].y * tempCanvas.height);
                        ctx.stroke();
                    });

                    const bgData = tempCanvas.toDataURL('image/jpeg', 0.85);
                    slide.background = { data: bgData };

                    const slideW = 10;
                    const slideH = 5.625;
                    const imgRatio = vpW / vpH;
                    const slideRatio = slideW / slideH;
                    
                    let finalW, finalH, finalX, finalY;
                    if (imgRatio > slideRatio) {
                         finalW = slideW; finalH = slideW / imgRatio; finalX = 0; finalY = (slideH - finalH) / 2;
                    } else {
                         finalH = slideH; finalW = slideH * imgRatio; finalY = 0; finalX = (slideW - finalW) / 2;
                    }

                    if (item.displayData) {
                        item.displayData.forEach((block, idx) => {
                            const state = item.blockStates[idx];
                            if (state === 1 || state === 2) {
                                const relX = block.box_2d[1] / 1000;
                                const relY = block.box_2d[0] / 1000;
                                const relW = (block.box_2d[3] - block.box_2d[1]) / 1000;
                                const relH = (block.box_2d[2] - block.box_2d[0]) / 1000;

                                const pptX = finalX + (relX * finalW);
                                const pptY = finalY + (relY * finalH);
                                const pptW = relW * finalW;
                                const pptH = relH * finalH;

                                let rawSize = block.font_size || 8; 
                                let fontSize = 10; 
                                if (rawSize >= 10) {
                                    fontSize = 14; 
                                } else {
                                    fontSize = 10; 
                                }
                                
                                const maxFontSizeBasedOnHeight = (pptH * 72) * 0.75; 
                                fontSize = Math.min(fontSize, maxFontSizeBasedOnHeight);
                                fontSize = fontSize * userFontScale;
                                fontSize = Math.min(20, Math.max(fontSize, 8));

                                slide.addText(block.text, {
                                    x: pptX, y: pptY, w: pptW, h: pptH,
                                    fontSize: fontSize,
                                    color: block.color ? block.color.replace('#','') : '000000',
                                    bold: block.is_bold,
                                    align: block.align || 'left',
                                    valign: 'top',
                                    fontFace: "Noto Sans TC" 
                                });
                            }
                        });
                    }
                }

                await pptx.writeFile({ fileName: 'NotebookLM_V37_19_PerfectUI.pptx' });

            } catch (err) {
                console.error(err);
                alert("åŒ¯å‡ºéŒ¯èª¤: " + err.message);
            }
            btn.disabled = false; btn.innerHTML = '<i data-lucide="download" class="w-4 h-4"></i> <span class="hidden sm:inline">ä¸‹è¼‰ PPT</span>';
            lucide.createIcons({ root: btn });
        }
        
        maskCanvas.addEventListener('mousedown', startDrawing);
        maskCanvas.addEventListener('mousemove', draw);
        maskCanvas.addEventListener('mouseup', stopDrawing);
        maskCanvas.addEventListener('mouseout', stopDrawing);
        maskCanvas.addEventListener('touchstart', (e)=>{e.preventDefault(); startDrawing(e.touches[0])}, {passive:false});
        maskCanvas.addEventListener('touchmove', (e)=>{e.preventDefault(); draw(e.touches[0])}, {passive:false});
        maskCanvas.addEventListener('touchend', stopDrawing);
    </script>
</body>
</html>
