<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
    <title>NotebookLM 轉 PPT (V37.53 最終 Noto Sans 版)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';</script>
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background-color: #f3f4f6; height: 100vh; overflow: hidden; }
        .page-card { transition: all 0.2s; border: 2px solid transparent; cursor: pointer; width: 100%; box-sizing: border-box; }
        .page-card.active { border-color: #2563eb; background-color: #eff6ff; }
        .ocr-box { position: absolute; z-index: 40; border-radius: 2px; font-family: 'Noto Sans TC', sans-serif; font-size: 12px; overflow: hidden; padding: 1px; line-height: 1.2; cursor: move; }
        .ocr-box.keep { border: 1px solid #22c55e; background-color: rgba(34, 197, 94, 0.1); }
        .ocr-box.reconstruct { border: 2px solid #ef4444; background-color: rgba(239, 68, 68, 0.15); }
        .ocr-box.selected { border: 2px solid #2563eb !important; box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.3); z-index: 60; }
        .resize-handle { position: absolute; width: 14px; height: 14px; background-color: #2563eb; border: 2px solid white; bottom: -7px; right: -7px; cursor: se-resize; border-radius: 50%; display: none; z-index: 61; }
        .ocr-box.selected .resize-handle { display: block; }
        .move-handle { position: absolute; width: 24px; height: 24px; background-color: #2563eb; top: -20px; left: 50%; transform: translateX(-50%); cursor: move; border-radius: 4px; display: none; align-items: center; justify-content: center; z-index: 62; }
        .move-handle::after { content: '+'; color: white; font-size: 18px; font-weight: bold; }
        .ocr-box.selected .move-handle { display: flex; }
        .delete-handle { position: absolute; width: 20px; height: 20px; background-color: #ef4444; bottom: -10px; left: -10px; cursor: pointer; border-radius: 50%; display: none; align-items: center; justify-content: center; z-index: 63; border: 2px solid white; }
        .delete-handle::after { content: '×'; color: white; font-size: 14px; font-weight: bold; }
        .ocr-box.selected .delete-handle { display: flex; }
        .loader { border: 3px solid #e5e7eb; border-top: 3px solid #2563eb; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="flex flex-col text-slate-800 h-screen w-full overflow-hidden">
    <header class="bg-white shadow-sm z-30 p-2 sm:p-3 flex justify-between items-center h-16 relative w-full">
        <div class="flex items-center gap-2"><div class="bg-indigo-600 text-white p-1.5 rounded-lg font-bold text-xl">V37.53</div><h1 class="font-bold">AI 全局擬合 Noto Sans 版</h1></div>
        <div class="flex items-center gap-3">
            <input type="password" id="apiKey" class="border rounded px-2 py-1 text-sm w-64" placeholder="Google Vision API Key">
            <label class="bg-slate-800 text-white px-3 py-2 rounded cursor-pointer text-sm shadow">開啟檔案<input type="file" id="fileInput" accept=".pdf" class="hidden"></label>
            <button id="downloadBtn" onclick="exportPPT()" class="bg-emerald-600 text-white px-3 py-2 rounded text-sm shadow disabled:opacity-50" disabled>下載 PPT</button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <div id="sidebar" class="w-64 bg-white border-r flex flex-col shrink-0 z-20"><div id="pagesList" class="flex-1 overflow-y-auto p-3 bg-slate-50 custom-scrollbar"></div></div>
        <div class="flex-1 bg-slate-100 relative flex flex-col h-full overflow-hidden">
            <div id="toolbar" class="hidden bg-white p-2 shadow-sm border-b flex items-center gap-4 overflow-x-auto whitespace-nowrap">
                <div class="flex items-center gap-1 bg-slate-100 p-1 rounded-lg border">
                    <button onclick="setMode('select')" id="btn-mode-select" class="px-3 py-1.5 rounded bg-white shadow text-indigo-700"><i data-lucide="mouse-pointer-2" class="w-4 h-4"></i></button>
                    <button onclick="setMode('brush')" id="btn-mode-brush" class="px-3 py-1.5 rounded text-slate-500"><i data-lucide="brush" class="w-4 h-4"></i></button>
                </div>
                <label class="flex items-center gap-2 text-xs font-bold"><input type="checkbox" id="mergeToggle" onchange="toggleMerge()" checked>合併</label>
                <button onclick="analyzeCurrentPage()" class="bg-indigo-50 text-indigo-700 px-3 py-1.5 rounded-lg text-xs font-bold border border-indigo-200">GCV 辨識</button>
                <button onclick="addTextBox()" class="bg-emerald-50 text-emerald-700 px-3 py-1.5 rounded-lg text-xs font-bold border border-emerald-200">新增框</button>
                <button id="eyedropperBtn" onclick="toggleEyedropper()" class="p-1.5 border rounded bg-white"><i data-lucide="pipette" class="w-4 h-4"></i></button>
                <input type="color" id="maskColor" value="#FFFFFF" class="w-8 h-8 rounded border p-0">
                <div class="flex flex-col border-l pl-2"><span class="text-[9px] font-bold">微調</span><input type="range" id="fontScale" min="0.5" max="1.5" step="0.01" value="1.0" class="w-16"></div>
                <button onclick="undoLastStroke()" class="p-1.5 border rounded bg-white"><i data-lucide="undo-2" class="w-4 h-4"></i></button>
                <button onclick="clearMask()" class="text-red-400 p-1.5"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
            </div>

            <div id="previewArea" class="flex-1 overflow-auto bg-slate-200 relative p-8 flex flex-col items-center">
                <div id="canvasContainer" class="relative shadow-2xl bg-white hidden m-auto">
                    <canvas id="pdfCanvas" class="absolute top-0 left-0 w-full h-full z-10"></canvas>
                    <canvas id="maskCanvas" class="absolute top-0 left-0 w-full h-full z-20 cursor-crosshair touch-none"></canvas>
                    <div id="textOverlay" class="absolute top-0 left-0 w-full h-full z-30"></div>
                    <div id="canvasLoader" class="absolute inset-0 bg-white/90 z-50 hidden flex flex-col items-center justify-center backdrop-blur-sm">
                        <div class="loader mb-3"></div><span class="text-sm font-bold text-slate-600">全局擬合 Noto Sans 優化中...</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        if (typeof lucide !== 'undefined') lucide.createIcons();
        let pdfDoc = null, pagesData = [], currentIndex = -1, editMode = 'select', isDrawing = false, isEyedropper = false;
        let selectedBlockIndex = -1, dragAction = null, dragStart = { x: 0, y: 0 }, activeBlockData = null;

        const pdfCanvas = document.getElementById('pdfCanvas'), maskCanvas = document.getElementById('maskCanvas'), maskCtx = maskCanvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer'), textOverlay = document.getElementById('textOverlay');
        const apiKeyInput = document.getElementById('apiKey'), canvasLoader = document.getElementById('canvasLoader'), maskColorInput = document.getElementById('maskColor');

        // --- V37.53 核心：針對 Noto Sans 優化的幾何擬合演算法 ---
        function calculateGlobalFitFS(block, text, fontScale) {
            const hPct = (block.box_pixels[2] - block.box_pixels[0]) / 1000;
            const wPct = (block.box_pixels[3] - block.box_pixels[1]) / 1000;
            const boxH_pt = hPct * 5.625 * 72;
            const boxW_pt = wPct * 10 * 72;
            
            const cjkCount = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
            const otherCount = text.length - cjkCount;
            // 針對 Noto Sans 調整寬度權重因子 (0.51)
            const widthWeight = 0.51; 
            const lineSpacing = 0.18; 

            let possibleFS = [];

            // 標題判定校準
            if (text.length < 15 && boxW_pt > boxH_pt * 4) {
                for (let scale = 1.15; scale >= 0.9; scale -= 0.05) {
                    let trialFS = boxH_pt * scale;
                    let estW = (cjkCount * 1.0 + otherCount * widthWeight) * trialFS;
                    if (estW <= boxW_pt * 1.2) return Math.max(8, Math.min(trialFS * fontScale, 200));
                }
            }

            // 內文判定校準
            for (let n = 1; n <= 8; n++) {
                let trialFS = boxH_pt / (n + (n - 1) * lineSpacing);
                let estW_per_line = ((cjkCount * 1.0 + otherCount * widthWeight) * trialFS) / n;
                if (estW_per_line <= boxW_pt * 1.35) {
                    possibleFS.push(trialFS);
                }
            }

            if (possibleFS.length > 0) {
                return Math.max(8, Math.min(Math.max(...possibleFS) * fontScale, 200));
            }
            return (boxH_pt / 5) * fontScale; 
        }

        function detectSmartFitColor(ctx, box, cvsW, cvsH, mode) {
            const x = (box[1]/1000)*cvsW, y = (box[0]/1000)*cvsH;
            const w = ((box[3]-box[1])/1000)*cvsW, h = ((box[2]-box[0])/1000)*cvsH;
            if (mode === 'bg') {
                const pts = [[x-8, y-8], [x+w+8, y-8], [x-8, y+h+8], [x+w+8, y+h+8], [x+w/2, y-8]];
                let r=0, g=0, b=0;
                pts.forEach(p => {
                    const d = ctx.getImageData(Math.max(0, Math.floor(p[0])), Math.max(0, Math.floor(p[1])), 1, 1).data;
                    r+=d[0]; g+=d[1]; b+=d[2];
                });
                return `rgb(${Math.floor(r/5)},${Math.floor(g/5)},${Math.floor(b/5)})`;
            } else {
                let minLum = 255, darkColor = {r:0,g:0,b:0};
                for(let i=1; i<=10; i++) {
                    const d = ctx.getImageData(Math.max(0, Math.floor(x + w*(i/11))), Math.floor(y + h/2), 1, 1).data;
                    const lum = (d[0]+d[1]+d[2])/3;
                    if (lum < minLum) { minLum = lum; darkColor = {r:d[0], g:d[1], b:d[2]}; }
                }
                if (minLum > 150) return "#000000"; 
                return "#" + [darkColor.r, darkColor.g, darkColor.b].map(v => v.toString(16).padStart(2, '0')).join('');
            }
        }

        document.getElementById('fileInput').onchange = async (e) => {
            const file = e.target.files[0]; if (!file) return;
            const buffer = await file.arrayBuffer();
            pdfDoc = await pdfjsLib.getDocument(new Uint8Array(buffer)).promise;
            pagesData = Array.from({ length: pdfDoc.numPages }, (_, i) => ({ pageNum: i + 1, strokes: [], rawData: null, displayData: null, viewport: null, el: null }));
            renderThumbnails();
        };

        async function renderThumbnails() {
            const list = document.getElementById('pagesList'); list.innerHTML = '';
            for (let i = 0; i < pagesData.length; i++) {
                const page = await pdfDoc.getPage(pagesData[i].pageNum);
                const vp = page.getViewport({ scale: 0.15 });
                const cvs = document.createElement('canvas'); cvs.width = vp.width; cvs.height = vp.height;
                await page.render({ canvasContext: cvs.getContext('2d'), viewport: vp }).promise;
                const div = document.createElement('div');
                div.className = 'page-card bg-white p-2 rounded border mb-2 shadow-sm'; div.innerHTML = `<img src="${cvs.toDataURL()}" class="w-full border rounded">`;
                div.onclick = () => loadPage(i); pagesData[i].el = div; pagesData[i].viewport = page.getViewport({ scale: 1.0 });
                list.appendChild(div);
            }
        }

        async function loadPage(index) {
            currentIndex = index; const item = pagesData[index];
            document.querySelectorAll('.page-card').forEach(c => c.classList.remove('active')); item.el.classList.add('active');
            document.getElementById('toolbar').classList.remove('hidden'); canvasContainer.classList.remove('hidden');
            const ratio = item.viewport.width / item.viewport.height;
            let finalW = window.innerWidth * 0.7; canvasContainer.style.width = `${finalW}px`; canvasContainer.style.height = `${finalW / ratio}px`;
            pdfCanvas.width = item.viewport.width * 2; pdfCanvas.height = item.viewport.height * 2;
            maskCanvas.width = pdfCanvas.width; maskCanvas.height = pdfCanvas.height;
            const page = await pdfDoc.getPage(item.pageNum);
            await page.render({ canvasContext: pdfCanvas.getContext('2d', { willReadFrequently: true }), viewport: page.getViewport({ scale: 2.0 }) }).promise;
            if (item.rawData) processData(item); 
            renderTextOverlay(item); redrawStrokes(item);
        }

        async function analyzeCurrentPage() {
            const key = apiKeyInput.value.trim(); if (!key) return alert('請輸入 Key');
            canvasLoader.classList.remove('hidden');
            try {
                const base64 = pdfCanvas.toDataURL('image/jpeg', 0.9).split(',')[1];
                const res = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${key}`, {
                    method: 'POST', body: JSON.stringify({ requests: [{ image: { content: base64 }, features: [{ type: "DOCUMENT_TEXT_DETECTION" }] }] })
                });
                const data = await res.json(), fullText = data.responses[0].fullTextAnnotation;
                const results = [];
                const ctx = pdfCanvas.getContext('2d', { willReadFrequently: true });
                fullText.pages[0].blocks.forEach(block => {
                    block.paragraphs.forEach(para => {
                        const v = para.boundingBox.vertices;
                        const xmin = Math.min(...v.map(p => p.x||0)) / pdfCanvas.width * 1000;
                        const ymin = Math.min(...v.map(p => p.y||0)) / pdfCanvas.height * 1000;
                        const xmax = Math.max(...v.map(p => p.x||0)) / pdfCanvas.width * 1000;
                        const ymax = Math.max(...v.map(p => p.y||0)) / pdfCanvas.height * 1000;
                        let text = ""; para.words.forEach(w => w.symbols.forEach(s => { text += s.text; if (s.property?.detectedBreak) text += " "; }));
                        const box = [ymin, xmin, ymax, xmax];
                        results.push({ id: 'raw_'+Date.now()+Math.random(), text: text.trim(), box_pixels: box, color: detectSmartFitColor(ctx, box, pdfCanvas.width, pdfCanvas.height, 'text'), state: 1 });
                    });
                });
                pagesData[currentIndex].rawData = results; processData(pagesData[currentIndex]); renderTextOverlay(pagesData[currentIndex]);
                document.getElementById('downloadBtn').disabled = false;
            } catch (e) { alert('辨識失敗'); } finally { canvasLoader.classList.add('hidden'); }
        }

        function mergeTextBlocks(blocks) {
            if (!blocks || blocks.length === 0) return [];
            let sorted = [...blocks].sort((a, b) => (Math.abs(a.box_pixels[0] - b.box_pixels[0]) < 5) ? a.box_pixels[1] - b.box_pixels[1] : a.box_pixels[0] - b.box_pixels[0]);
            let merged = [];
            for (let curr of sorted) {
                if (merged.length === 0) { merged.push({...curr, sourceIds: [curr.id]}); continue; }
                let prev = merged[merged.length - 1];
                if (Math.abs(curr.box_pixels[0] - prev.box_pixels[0]) < 5 && (curr.box_pixels[1] - prev.box_pixels[3]) < 12) {
                    const isCJK = (c) => /[\u4e00-\u9fa5]/.test(c);
                    prev.text += (isCJK(prev.text.slice(-1)) && isCJK(curr.text[0]) ? "" : " ") + curr.text;
                    prev.box_pixels[3] = Math.max(prev.box_pixels[3], curr.box_pixels[3]);
                    prev.sourceIds.push(curr.id);
                } else { merged.push({...curr, sourceIds: [curr.id]}); }
            }
            return merged;
        }

        function toggleMerge() { if(currentIndex >= 0) { processData(pagesData[currentIndex]); renderTextOverlay(pagesData[currentIndex]); } }
        function processData(item) { item.displayData = document.getElementById('mergeToggle').checked ? mergeTextBlocks(item.rawData) : item.rawData; }

        function renderTextOverlay(item) {
            textOverlay.innerHTML = ''; if (!item.displayData) return;
            item.displayData.forEach((block, idx) => {
                const div = document.createElement('div'), state = block.state || 0;
                div.className = `ocr-box ${state === 0 ? 'keep' : 'reconstruct'} ${idx === selectedBlockIndex ? 'selected' : ''}`;
                div.style.top = `${block.box_pixels[0]/10}%`; div.style.left = `${block.box_pixels[1]/10}%`;
                div.style.width = `${(block.box_pixels[3]-block.box_pixels[1])/10}%`; div.style.height = `${(block.box_pixels[2]-block.box_pixels[0])/10}%`;
                const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-handle'; deleteBtn.onclick = (e) => { e.stopPropagation(); deleteTextBox(idx); };
                div.innerHTML = `<div class="resize-handle"></div><div class="move-handle"></div>`; div.appendChild(deleteBtn);
                div.onclick = (e) => { e.stopPropagation(); selectedBlockIndex = idx; renderTextOverlay(item); };
                div.ondblclick = (e) => { e.stopPropagation(); block.state = block.state === 1 ? 0 : 1; renderTextOverlay(item); };
                textOverlay.appendChild(div);
            });
        }

        function deleteTextBox(idx) {
            const item = pagesData[currentIndex], block = item.displayData[idx], ids = block.sourceIds || [block.id];
            item.rawData = item.rawData.filter(r => !ids.includes(r.id));
            processData(item); selectedBlockIndex = -1; renderTextOverlay(item);
        }

        async function exportPPT() {
            const pptx = new PptxGenJS(); pptx.layout = 'LAYOUT_16x9';
            const fScale = parseFloat(document.getElementById('fontScale').value);
            for (const item of pagesData) {
                if (!item.displayData && item.strokes.length === 0) continue;
                const slide = pptx.addSlide(), tempCvs = document.createElement('canvas');
                tempCvs.width = pdfCanvas.width; tempCvs.height = pdfCanvas.height;
                const ctx = tempCvs.getContext('2d', { willReadFrequently: true }); 
                ctx.drawImage(pdfCanvas, 0, 0);
                if (item.displayData) {
                    item.displayData.forEach(b => {
                        if (b.state === 1) {
                            const x = (b.box_pixels[1]/1000)*tempCvs.width, y = (b.box_pixels[0]/1000)*tempCvs.height;
                            const w = ((b.box_pixels[3]-b.box_pixels[1])/1000)*tempCvs.width, h = ((b.box_pixels[2]-b.box_pixels[0])/1000)*tempCvs.height;
                            ctx.fillStyle = detectSmartFitColor(ctx, b.box_pixels, tempCvs.width, tempCvs.height, 'bg');
                            ctx.fillRect(Math.floor(x-2), Math.floor(y-2), Math.ceil(w+4), Math.ceil(h+4));
                        }
                    });
                }
                slide.background = { data: tempCvs.toDataURL('image/jpeg', 0.9) };
                if (item.displayData) {
                    item.displayData.forEach(b => {
                        if (b.state === 1) {
                            slide.addText(b.text, { 
                                x: (b.box_pixels[1]/1000)*10, y: (b.box_pixels[0]/1000)*5.625, 
                                w: ((b.box_pixels[3]-b.box_pixels[1])/1000)*10, h: ((b.box_pixels[2]-b.box_pixels[0])/1000)*5.625, 
                                fontSize: calculateGlobalFitFS(b, b.text, fScale), color: b.color.replace('#',''), 
                                fontFace: "Noto Sans", valign: 'middle', align: 'left', margin: 0,
                                shrinkText: false, wrap: true
                            });
                        }
                    });
                }
            }
            pptx.writeFile({ fileName: `Visual_Peak_NotoSans_V37.53.pptx` });
        }

        function toggleEyedropper() { isEyedropper = !isEyedropper; document.getElementById('eyedropperBtn').classList.toggle('bg-blue-100', isEyedropper); }
        function setMode(m) { editMode = m; document.getElementById('btn-mode-select').className = m === 'select' ? 'px-3 py-1.5 rounded bg-white shadow text-indigo-700' : 'px-3 py-1.5 rounded text-slate-500'; document.getElementById('btn-mode-brush').className = m === 'brush' ? 'px-3 py-1.5 rounded bg-white shadow text-indigo-700' : 'px-3 py-1.5 rounded text-slate-500'; maskCanvas.style.pointerEvents = (m === 'brush') ? 'auto' : 'none'; textOverlay.style.pointerEvents = (m === 'select') ? 'auto' : 'none'; }
        maskCanvas.addEventListener('mousedown', (e) => {
            if (isEyedropper) {
                const r = maskCanvas.getBoundingClientRect(), x = (e.clientX - r.left) * (pdfCanvas.width / r.width), y = (e.clientY - r.top) * (pdfCanvas.height / r.height);
                const p = pdfCanvas.getContext('2d', { willReadFrequently: true }).getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
                maskColorInput.value = "#" + ((1 << 24) + (p[0] << 16) + (p[1] << 8) + p[2]).toString(16).slice(1);
                toggleEyedropper(); return;
            }
            if (editMode !== 'brush') return;
            isDrawing = true; const r = maskCanvas.getBoundingClientRect();
            pagesData[currentIndex].strokes.push({ color: maskColorInput.value, normSize: 0.02, points: [{ x: (e.clientX - r.left) / r.width, y: (e.clientY - r.top) / r.height }] });
        });
        maskCanvas.addEventListener('mousemove', (e) => { if (isDrawing && editMode === 'brush') { const r = maskCanvas.getBoundingClientRect(); pagesData[currentIndex].strokes.slice(-1)[0].points.push({ x: (e.clientX - r.left) / r.width, y: (e.clientY - r.top) / r.height }); redrawStrokes(pagesData[currentIndex]); } });
        window.addEventListener('mouseup', () => { isDrawing = false; });
        function redrawStrokes(item) { maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height); item.strokes.forEach(s => { maskCtx.beginPath(); maskCtx.strokeStyle = s.color; maskCtx.lineWidth = s.normSize * maskCanvas.width; maskCtx.lineCap = 'round'; maskCtx.moveTo(s.points[0].x * maskCanvas.width, s.points[0].y * maskCanvas.height); s.points.forEach(p => maskCtx.lineTo(p.x * maskCanvas.width, p.y * maskCanvas.height)); maskCtx.stroke(); }); }
        function addTextBox() { if(!pagesData[currentIndex].rawData) pagesData[currentIndex].rawData=[]; pagesData[currentIndex].rawData.push({ id: 'man_' + Date.now(), text: "手動文字", box_pixels: [450, 400, 500, 600], color: "#000000", state: 1 }); processData(pagesData[currentIndex]); renderTextOverlay(pagesData[currentIndex]); }
    </script>
</body>
</html>
